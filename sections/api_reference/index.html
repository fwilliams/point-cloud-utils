<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><link rel="canonical" href="https://www.fwilliams.info/point-cloud-utils/sections/api_reference/" />
      <link rel="shortcut icon" href="../../img/favicon.ico" />
    <title>API Reference - Point Cloud Utils</title>
    <link rel="stylesheet" href="../../css/theme.css" />
    <link rel="stylesheet" href="../../css/theme_extra.css" />
        <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.5.0/styles/github.min.css" />
        <link href="../../assets/_mkdocstrings.css" rel="stylesheet" />
    
      <script>
        // Current page data
        var mkdocs_page_name = "API Reference";
        var mkdocs_page_input_path = "sections/api_reference.md";
        var mkdocs_page_url = "/point-cloud-utils/sections/api_reference/";
      </script>
    
    <script src="../../js/jquery-3.6.0.min.js" defer></script>
    <!--[if lt IE 9]>
      <script src="../../js/html5shiv.min.js"></script>
    <![endif]-->
      <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.5.0/highlight.min.js"></script>
      <script>hljs.initHighlightingOnLoad();</script> 
</head>

<body class="wy-body-for-nav" role="document">

  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side stickynav">
    <div class="wy-side-scroll">
      <div class="wy-side-nav-search">
          <a href="../.." class="icon icon-home"> Point Cloud Utils
        </a><div role="search">
  <form id ="rtd-search-form" class="wy-form" action="../../search.html" method="get">
      <input type="text" name="q" placeholder="Search docs" title="Type search term here" />
  </form>
</div>
      </div>

      <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <ul>
                <li class="toctree-l1"><a class="reference internal" href="../..">Home</a>
                </li>
              </ul>
              <p class="caption"><span class="caption-text">Functionality</span></p>
              <ul>
                  <li class="toctree-l1"><a class="reference internal" href="../mesh_io/">Mesh and Point Cloud I/O</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../point_cloud_resampling/">Resampling Point Clouds</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../mesh_sampling/">Generating Point Samples on a Mesh</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../shape_metrics/">Point Cloud Metrics</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../watertight_manifold/">Making a Mesh a Watertight Manifold</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../mesh_sdf/">Computing Signed Distances (SDFs) to Meshes</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../point_cloud_normal_estimation/">Estimating Normals for Point Clouds</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../mesh_normal_estimation/">Computing Mesh Normals</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../ray_mesh_intersection/">Ray/Mesh Intersection</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../surfels/">Generating Surfels from Point Clouds</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../mesh_smoothing/">Smoothing a Mesh</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../mesh_decimation/">Decimating a Mesh</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../closest_point_on_mesh/">Finding Closest Points Between Point Clouds and Meshes</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../computing_connected_components_of_a_mesh/">Computing Connected Components of a Mesh</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../deduplicating_point_clouds_and_meshes/">Deduplicating Point Clouds and Meshes</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../calculating_mesh_face_areas/">Calculating Mesh Face Areas</a>
                  </li>
                  <li class="toctree-l1"><a class="reference internal" href="../consistently_orienting_mesh_faces/">Consistently Orienting Mesh Faces</a>
                  </li>
              </ul>
              <p class="caption"><span class="caption-text">Recipes</span></p>
              <ul>
                  <li class="toctree-l1"><a class="reference internal" href="../cleaning_shapenet/">Making a ShapeNet SDF dataset</a>
                  </li>
              </ul>
              <p class="caption"><span class="caption-text">API Reference</span></p>
              <ul class="current">
                  <li class="toctree-l1 current"><a class="reference internal current" href="./">API Reference</a>
    <ul class="current">
    <li class="toctree-l2"><a class="reference internal" href="#point_cloud_utils.RayMeshIntersector">RayMeshIntersector</a>
        <ul>
    <li class="toctree-l3"><a class="reference internal" href="#point_cloud_utils._ray_mesh_intersector.RayMeshIntersector.__init__">__init__()</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#point_cloud_utils._ray_mesh_intersector.RayMeshIntersector.intersect_rays">intersect_rays()</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#point_cloud_utils.RaySurfelIntersector">RaySurfelIntersector</a>
        <ul>
    <li class="toctree-l3"><a class="reference internal" href="#point_cloud_utils._ray_point_cloud_intersector.RaySurfelIntersector.__init__">__init__()</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#point_cloud_utils._ray_point_cloud_intersector.RaySurfelIntersector.intersect_rays">intersect_rays()</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#point_cloud_utils.TriangleMesh">TriangleMesh</a>
        <ul>
    <li class="toctree-l3"><a class="reference internal" href="#point_cloud_utils._mesh_io.TriangleMesh.f">f</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#point_cloud_utils._mesh_io.TriangleMesh.fc">fc</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#point_cloud_utils._mesh_io.TriangleMesh.fn">fn</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#point_cloud_utils._mesh_io.TriangleMesh.v">v</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#point_cloud_utils._mesh_io.TriangleMesh.vc">vc</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#point_cloud_utils._mesh_io.TriangleMesh.vn">vn</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#point_cloud_utils._mesh_io.TriangleMesh.FaceData">FaceData</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#point_cloud_utils._mesh_io.TriangleMesh.VertexData">VertexData</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#point_cloud_utils._mesh_io.TriangleMesh.load">load()</a>
    </li>
    <li class="toctree-l3"><a class="reference internal" href="#point_cloud_utils._mesh_io.TriangleMesh.save">save()</a>
    </li>
        </ul>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#point_cloud_utils.chamfer_distance">chamfer_distance()</a>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#point_cloud_utils.closest_points_on_mesh">closest_points_on_mesh()</a>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#point_cloud_utils.connected_components">connected_components()</a>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#point_cloud_utils.decimate_triangle_mesh">decimate_triangle_mesh()</a>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#point_cloud_utils.deduplicate_mesh_vertices">deduplicate_mesh_vertices()</a>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#point_cloud_utils.deduplicate_point_cloud">deduplicate_point_cloud()</a>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#point_cloud_utils.dilate_sparse_voxel_grid">dilate_sparse_voxel_grid()</a>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#point_cloud_utils.downsample_point_cloud_on_voxel_grid">downsample_point_cloud_on_voxel_grid()</a>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#point_cloud_utils.downsample_point_cloud_poisson_disk">downsample_point_cloud_poisson_disk()</a>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#point_cloud_utils.earth_movers_distance">earth_movers_distance()</a>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#point_cloud_utils.erode_sparse_voxel_grid">erode_sparse_voxel_grid()</a>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#point_cloud_utils.estimate_mesh_face_normals">estimate_mesh_face_normals()</a>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#point_cloud_utils.estimate_mesh_vertex_normals">estimate_mesh_vertex_normals()</a>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#point_cloud_utils.estimate_point_cloud_normals_ball">estimate_point_cloud_normals_ball()</a>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#point_cloud_utils.estimate_point_cloud_normals_knn">estimate_point_cloud_normals_knn()</a>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#point_cloud_utils.hausdorff_distance">hausdorff_distance()</a>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#point_cloud_utils.interpolate_barycentric_coords">interpolate_barycentric_coords()</a>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#point_cloud_utils.k_nearest_neighbors">k_nearest_neighbors()</a>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#point_cloud_utils.laplacian_smooth_mesh">laplacian_smooth_mesh()</a>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#point_cloud_utils.lloyd_2d">lloyd_2d()</a>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#point_cloud_utils.lloyd_3d">lloyd_3d()</a>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#point_cloud_utils.load_mesh_v">load_mesh_v()</a>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#point_cloud_utils.load_mesh_vc">load_mesh_vc()</a>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#point_cloud_utils.load_mesh_vf">load_mesh_vf()</a>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#point_cloud_utils.load_mesh_vfn">load_mesh_vfn()</a>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#point_cloud_utils.load_mesh_vfnc">load_mesh_vfnc()</a>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#point_cloud_utils.load_mesh_vn">load_mesh_vn()</a>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#point_cloud_utils.load_mesh_vnc">load_mesh_vnc()</a>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#point_cloud_utils.load_triangle_mesh">load_triangle_mesh()</a>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#point_cloud_utils.make_mesh_watertight">make_mesh_watertight()</a>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#point_cloud_utils.marching_cubes_sparse_voxel_grid">marching_cubes_sparse_voxel_grid()</a>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#point_cloud_utils.mesh_face_areas">mesh_face_areas()</a>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#point_cloud_utils.mesh_mean_and_gaussian_curvatures">mesh_mean_and_gaussian_curvatures()</a>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#point_cloud_utils.mesh_principal_curvatures">mesh_principal_curvatures()</a>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#point_cloud_utils.morton_add">morton_add()</a>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#point_cloud_utils.morton_decode">morton_decode()</a>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#point_cloud_utils.morton_encode">morton_encode()</a>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#point_cloud_utils.morton_knn">morton_knn()</a>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#point_cloud_utils.morton_subtract">morton_subtract()</a>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#point_cloud_utils.one_sided_hausdorff_distance">one_sided_hausdorff_distance()</a>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#point_cloud_utils.orient_mesh_faces">orient_mesh_faces()</a>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#point_cloud_utils.pairwise_distances">pairwise_distances()</a>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#point_cloud_utils.point_cloud_fast_winding_number">point_cloud_fast_winding_number()</a>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#point_cloud_utils.quantize_subdivided_sparse_voxel_grid">quantize_subdivided_sparse_voxel_grid()</a>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#point_cloud_utils.ray_mesh_intersection">ray_mesh_intersection()</a>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#point_cloud_utils.ray_surfel_intersection">ray_surfel_intersection()</a>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#point_cloud_utils.remove_unreferenced_mesh_vertices">remove_unreferenced_mesh_vertices()</a>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#point_cloud_utils.sample_mesh_lloyd">sample_mesh_lloyd()</a>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#point_cloud_utils.sample_mesh_poisson_disk">sample_mesh_poisson_disk()</a>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#point_cloud_utils.sample_mesh_random">sample_mesh_random()</a>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#point_cloud_utils.save_mesh_v">save_mesh_v()</a>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#point_cloud_utils.save_mesh_vc">save_mesh_vc()</a>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#point_cloud_utils.save_mesh_vf">save_mesh_vf()</a>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#point_cloud_utils.save_mesh_vfn">save_mesh_vfn()</a>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#point_cloud_utils.save_mesh_vfnc">save_mesh_vfnc()</a>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#point_cloud_utils.save_mesh_vn">save_mesh_vn()</a>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#point_cloud_utils.save_mesh_vnc">save_mesh_vnc()</a>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#point_cloud_utils.save_triangle_mesh">save_triangle_mesh()</a>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#point_cloud_utils.signed_distance_to_mesh">signed_distance_to_mesh()</a>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#point_cloud_utils.sinkhorn">sinkhorn()</a>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#point_cloud_utils.sparse_voxel_grid_boundary">sparse_voxel_grid_boundary()</a>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#point_cloud_utils.sparse_voxel_grid_from_pointcloud">sparse_voxel_grid_from_pointcloud()</a>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#point_cloud_utils.sparse_voxel_grid_to_hex_mesh">sparse_voxel_grid_to_hex_mesh()</a>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#point_cloud_utils.subdivide_sparse_voxel_grid">subdivide_sparse_voxel_grid()</a>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#point_cloud_utils.surfel_geometry">surfel_geometry()</a>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#point_cloud_utils.triangle_soup_fast_winding_number">triangle_soup_fast_winding_number()</a>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#point_cloud_utils.unquantize_subdivided_sparse_voxel_grid">unquantize_subdivided_sparse_voxel_grid()</a>
    </li>
    <li class="toctree-l2"><a class="reference internal" href="#point_cloud_utils.voronoi_centroids_unit_cube">voronoi_centroids_unit_cube()</a>
    </li>
    </ul>
                  </li>
              </ul>
      </div>
    </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">
      <nav class="wy-nav-top" role="navigation" aria-label="Mobile navigation menu">
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../..">Point Cloud Utils</a>
        
      </nav>
      <div class="wy-nav-content">
        <div class="rst-content"><div role="navigation" aria-label="breadcrumbs navigation">
  <ul class="wy-breadcrumbs">
    <li><a href="../.." class="icon icon-home" alt="Docs"></a> &raquo;</li>
          <li>API Reference &raquo;</li>
      <li>API Reference</li>
    <li class="wy-breadcrumbs-aside">
          <a href="https://github.com/fwilliams/point-cloud-utils/tree/master/docs/docs/sections/api_reference.md" class="icon icon-github"> Edit on GitHub</a>
    </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
            <div class="section" itemprop="articleBody">
              
                <h1 id="api-reference">API Reference</h1>


<div class="doc doc-object doc-class">



<h2 id="point_cloud_utils.RayMeshIntersector" class="doc doc-heading">
        <code>point_cloud_utils.RayMeshIntersector</code>


</h2>


  <div class="doc doc-contents first">

  
      <p>Class used to find the intersection between rays and a triangle mesh.</p>



  

  <div class="doc doc-children">









<div class="doc doc-object doc-function">



<h3 id="point_cloud_utils._ray_mesh_intersector.RayMeshIntersector.__init__" class="doc doc-heading">
<code class="highlight language-python"><span class="fm">__init__</span><span class="p">(</span><span class="n">mesh_v</span><span class="p">,</span> <span class="n">mesh_f</span><span class="p">)</span></code>

</h3>


  <div class="doc doc-contents ">
  
      <p>Create a RayMeshIntersector object which can be used to do ray/mesh queries with a triangle mesh.</p>

  <p><strong>Parameters:</strong></p>
  <table>
    <thead>
      <tr>
        <th>Name</th>
        <th>Type</th>
        <th>Description</th>
        <th>Default</th>
      </tr>
    </thead>
    <tbody>
        <tr>
          <td><code>mesh_v</code></td>
          <td>
          </td>
          <td><p>#v by 3 array of vertex positions (each row is a vertex)</p></td>
          <td>
              <em>required</em>
          </td>
        </tr>
        <tr>
          <td><code>mesh_f</code></td>
          <td>
          </td>
          <td><p>#f by 3 Matrix of face (triangle) indices</p></td>
          <td>
              <em>required</em>
          </td>
        </tr>
    </tbody>
  </table>

  </div>

</div>

<div class="doc doc-object doc-function">



<h3 id="point_cloud_utils._ray_mesh_intersector.RayMeshIntersector.intersect_rays" class="doc doc-heading">
<code class="highlight language-python"><span class="n">intersect_rays</span><span class="p">(</span><span class="n">ray_o</span><span class="p">,</span> <span class="n">ray_d</span><span class="p">,</span> <span class="n">ray_near</span><span class="o">=</span><span class="mf">0.0</span><span class="p">,</span> <span class="n">ray_far</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">)</span></code>

</h3>


  <div class="doc doc-contents ">
  
      <p>Compute intersection between a set of rays and the triangle mesh enclosed in this class</p>

  <p><strong>Parameters:</strong></p>
  <table>
    <thead>
      <tr>
        <th>Name</th>
        <th>Type</th>
        <th>Description</th>
        <th>Default</th>
      </tr>
    </thead>
    <tbody>
        <tr>
          <td><code>ray_o</code></td>
          <td>
          </td>
          <td><p>array of shape (#rays, 3) of ray origins (one per row) or a single array of shape (3,) to use</p></td>
          <td>
              <em>required</em>
          </td>
        </tr>
        <tr>
          <td><code>ray_d</code></td>
          <td>
          </td>
          <td><p>array of shape (#rays, 3) of ray directions (one per row)</p></td>
          <td>
              <em>required</em>
          </td>
        </tr>
        <tr>
          <td><code>ray_near</code></td>
          <td>
          </td>
          <td><p>an optional floating point value indicating the distance along each ray to start searching (default 0.0)</p></td>
          <td>
                <code>0.0</code>
          </td>
        </tr>
        <tr>
          <td><code>ray_far</code></td>
          <td>
          </td>
          <td><p>an optional floating point value indicating the maximum distance along each ray to search (default inf)</p></td>
          <td>
                <code>np.inf</code>
          </td>
        </tr>
    </tbody>
  </table>

  <p><strong>Returns:</strong></p>
  <table>
    <thead>
      <tr>
<th>Name</th>        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
        <tr>
<td><code>f_id</code></td>          <td>
          </td>
          <td><p>an array of shape (#rays,) representing the face id hit by each ray</p></td>
        </tr>
        <tr>
<td><code>bc</code></td>          <td>
          </td>
          <td><p>an array of shape (#rays, 3) where each row is the barycentric coordinates within each face of the ray intersection</p></td>
        </tr>
        <tr>
<td><code>t</code></td>          <td>
          </td>
          <td><p>the distance along each ray to the intersection</p></td>
        </tr>
    </tbody>
  </table>

  </div>

</div>



  </div>

  </div>

</div><hr />


<div class="doc doc-object doc-class">



<h2 id="point_cloud_utils.RaySurfelIntersector" class="doc doc-heading">
        <code>point_cloud_utils.RaySurfelIntersector</code>


</h2>


  <div class="doc doc-contents first">

  
      <p>Class used to find the intersection between rays and a point cloud converted to surfels (i.e. a point cloud
represented as circles centered at each point and oriented perpendicularly to each normal).</p>



  

  <div class="doc doc-children">









<div class="doc doc-object doc-function">



<h3 id="point_cloud_utils._ray_point_cloud_intersector.RaySurfelIntersector.__init__" class="doc doc-heading">
<code class="highlight language-python"><span class="fm">__init__</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">r</span><span class="o">=</span><span class="mf">0.1</span><span class="p">,</span> <span class="n">subdivs</span><span class="o">=</span><span class="mi">7</span><span class="p">)</span></code>

</h3>


  <div class="doc doc-contents ">
  
      <p>Construct a RayPointCloudIntersector which can be used to compute the intersection between a set of rays and a
point cloud converted to circular patches oriented with the point normals</p>

  <p><strong>Parameters:</strong></p>
  <table>
    <thead>
      <tr>
        <th>Name</th>
        <th>Type</th>
        <th>Description</th>
        <th>Default</th>
      </tr>
    </thead>
    <tbody>
        <tr>
          <td><code>p</code></td>
          <td>
          </td>
          <td><p>#p by 3 array of vertex positions (each row is a vertex)</p></td>
          <td>
              <em>required</em>
          </td>
        </tr>
        <tr>
          <td><code>n</code></td>
          <td>
          </td>
          <td><p>#p by 3 Matrix of vertex normals (each row is a vertex)</p></td>
          <td>
              <em>required</em>
          </td>
        </tr>
        <tr>
          <td><code>r</code></td>
          <td>
          </td>
          <td><p>Array or Scalar describing the size of each geometry element (Either one radius per vertex, or a global size for the whole point cloud)</p></td>
          <td>
                <code>0.1</code>
          </td>
        </tr>
        <tr>
          <td><code>subdivs</code></td>
          <td>
          </td>
          <td><p>Number of times to subdivide the patch geometry for each point (i.e. # tris per cicle)</p></td>
          <td>
                <code>7</code>
          </td>
        </tr>
    </tbody>
  </table>

  </div>

</div>

<div class="doc doc-object doc-function">



<h3 id="point_cloud_utils._ray_point_cloud_intersector.RaySurfelIntersector.intersect_rays" class="doc doc-heading">
<code class="highlight language-python"><span class="n">intersect_rays</span><span class="p">(</span><span class="n">ray_o</span><span class="p">,</span> <span class="n">ray_d</span><span class="p">,</span> <span class="n">ray_near</span><span class="o">=</span><span class="mf">0.0</span><span class="p">,</span> <span class="n">ray_far</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">)</span></code>

</h3>


  <div class="doc doc-contents ">
  
      <p>Compute intersection between a set of rays and the point cloud converted to circular patches oriented with the
point normals</p>

  <p><strong>Parameters:</strong></p>
  <table>
    <thead>
      <tr>
        <th>Name</th>
        <th>Type</th>
        <th>Description</th>
        <th>Default</th>
      </tr>
    </thead>
    <tbody>
        <tr>
          <td><code>ray_o</code></td>
          <td>
          </td>
          <td><p>array of shape (#rays, 3) of ray origins (one per row) or a single array of shape (3,) to use</p></td>
          <td>
              <em>required</em>
          </td>
        </tr>
        <tr>
          <td><code>ray_d</code></td>
          <td>
          </td>
          <td><p>array of shape (#rays, 3) of ray directions (one per row)</p></td>
          <td>
              <em>required</em>
          </td>
        </tr>
        <tr>
          <td><code>ray_near</code></td>
          <td>
          </td>
          <td><p>an optional floating point value indicating the distance along each ray to start searching (default 0.0)</p></td>
          <td>
                <code>0.0</code>
          </td>
        </tr>
        <tr>
          <td><code>ray_far</code></td>
          <td>
          </td>
          <td><p>an optional floating point value indicating the maximum distance along each ray to search (default inf)</p></td>
          <td>
                <code>np.inf</code>
          </td>
        </tr>
    </tbody>
  </table>

  <p><strong>Returns:</strong></p>
  <table>
    <thead>
      <tr>
<th>Name</th>        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
        <tr>
<td><code>t</code></td>          <td>
          </td>
          <td><p>a (#rays,) shaped array encoding the distance between the ray origin and intersection point for each ray (inf for missed rays)</p></td>
        </tr>
        <tr>
<td><code>pid</code></td>          <td>
          </td>
          <td><p>a (#rays,) shaped array of integer indices corresponding to which points were hit (-1 for a ray miss)</p></td>
        </tr>
    </tbody>
  </table>

  </div>

</div>



  </div>

  </div>

</div><hr />


<div class="doc doc-object doc-class">



<h2 id="point_cloud_utils.TriangleMesh" class="doc doc-heading">
        <code>point_cloud_utils.TriangleMesh</code>


</h2>


  <div class="doc doc-contents first">

  
      <p>A lightweight container class representing a triangle mesh with attributes stored at each vertex, wedge, and face, where:</p>
<ul>
<li>A vertex is a 3D position</li>
<li>A wedge is a vertex and its two adjacent edges</li>
<li>A face is a triangle connecting 3 vertices (Each triangle has 3 vertices and 3 wedges).</li>
</ul>
<p>The data in encapsulated into vertex data and face data, accessible via <code>TriangleMes.vertex_data</code> and <code>TriangleMesh.face_data</code> respectively:</p>
<p><code>TriangleMesh.vertex_data</code>:</p>
<ul>
<li><code>positions</code>: [V, 3]-shaped numpy array of per-vertex positions</li>
<li><code>normals</code>: [V, 3]-shaped numpy array of per-vertex normals (or None)</li>
<li><code>texcoords</code>: [V, 2]-shaped numpy array of per-vertex uv coordinates (or None)</li>
<li><code>tex_ids</code>: [V,]-shaped numpy array of integer indices into TriangleMesh.textures indicating which texture to use at this vertex (or None)</li>
<li><code>colors</code>: [V, 4]-shaped numpy array of per-vertex RBGA colors in [0.0, 1.0] (or None)</li>
<li><code>radius</code>: [V,]-shaped numpy array of per-vertex curvature radii (or None)</li>
<li><code>quality</code>: [V,]-shaped numpy array of per-vertex quality measures (or None)</li>
<li><code>flags</code>: [V,]-shaped numpy array of 32-bit integer flags per vertex (or None)</li>
</ul>
<p><code>TriangleMesh.face_data</code>:</p>
<ul>
<li><code>vertex_ids</code>: [F, 3]-shaped numpy array of integer face indices into TrianglMesh.vertex_data.positions</li>
<li><code>normals</code>: [F, 3]-shaped numpy array of per-face normals (or None)</li>
<li><code>colors</code>: [F, 4]-shaped numpy array of per-face RBGA colors in [0.0, 1.0] (or None)</li>
<li><code>quality</code>: [F,]-shaped numpy array of per-face quality measures (or None)</li>
<li><code>flags</code>: [F,]-shaped numpy array of 32-bit integer flags per face (or None)</li>
<li><code>wedge_colors</code>: [F, 3, 4]-shaped numpy array of per-wedge RBGA colors in [0.0, 1.0] (or None)</li>
<li><code>wedge_normals</code>: [F, 3, 3]-shaped numpy array of per-wedge normals (or None)</li>
<li><code>wedge_texcoords</code>: [F, 3, 2]-shaped numpy array of per-wedge] uv coordinates (or None)</li>
<li><code>wedge_tex_ids</code>: [F, 3]-shaped numpy array of integer indices into TriangleMesh.textures indicating which texture to use at this wedge (or None)</li>
<li><code>textures</code>: A list of paths to texture image files for this mesh</li>
<li><code>normal_maps</code>: A list of paths to texture image files for this mesh</li>
</ul>



  

  <div class="doc doc-children">







<div class="doc doc-object doc-attribute">



<h3 id="point_cloud_utils._mesh_io.TriangleMesh.f" class="doc doc-heading">
<code class="highlight language-python"><span class="n">f</span></code>
  
  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-property"><code>property</code></small>
  </span>

</h3>


  <div class="doc doc-contents ">
  
      <p>An (m, 3)-shaped integer array containing this mesh's face indices (None if no faces)</p>
  </div>

</div>

<div class="doc doc-object doc-attribute">



<h3 id="point_cloud_utils._mesh_io.TriangleMesh.fc" class="doc doc-heading">
<code class="highlight language-python"><span class="n">fc</span></code>
  
  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-property"><code>property</code></small>
  </span>

</h3>


  <div class="doc doc-contents ">
  
      <p>An (m, 4)-shaped array containing this mesh's per-face RBGA colors (None if no face colors)</p>
  </div>

</div>

<div class="doc doc-object doc-attribute">



<h3 id="point_cloud_utils._mesh_io.TriangleMesh.fn" class="doc doc-heading">
<code class="highlight language-python"><span class="n">fn</span></code>
  
  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-property"><code>property</code></small>
  </span>

</h3>


  <div class="doc doc-contents ">
  
      <p>An (m, 3)-shaped array containing this mesh's per-face normals (None if no face normals)</p>
  </div>

</div>

<div class="doc doc-object doc-attribute">



<h3 id="point_cloud_utils._mesh_io.TriangleMesh.v" class="doc doc-heading">
<code class="highlight language-python"><span class="n">v</span></code>
  
  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-property"><code>property</code></small>
  </span>

</h3>


  <div class="doc doc-contents ">
  
      <p>An (n, 3)-shaped array containing this mesh's vertex positions</p>
  </div>

</div>

<div class="doc doc-object doc-attribute">



<h3 id="point_cloud_utils._mesh_io.TriangleMesh.vc" class="doc doc-heading">
<code class="highlight language-python"><span class="n">vc</span></code>
  
  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-property"><code>property</code></small>
  </span>

</h3>


  <div class="doc doc-contents ">
  
      <p>An (n, 4)-shaped array containing this mesh's per-vertex RGBA (None if no vertex colors)</p>
  </div>

</div>

<div class="doc doc-object doc-attribute">



<h3 id="point_cloud_utils._mesh_io.TriangleMesh.vn" class="doc doc-heading">
<code class="highlight language-python"><span class="n">vn</span></code>
  
  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-property"><code>property</code></small>
  </span>

</h3>


  <div class="doc doc-contents ">
  
      <p>An (n, 3)-shaped array containing this mesh's per-vertex normals (None if no vertex normals)</p>
  </div>

</div>


<div class="doc doc-object doc-class">



<h3 id="point_cloud_utils._mesh_io.TriangleMesh.FaceData" class="doc doc-heading">
        <code>FaceData</code>


</h3>


  <div class="doc doc-contents ">

  
      <p>A lightweight container class representing per-face information within a TriangleMesh with the following attributes</p>
<ul>
<li><code>vertex_ids</code>: [F, 3]-shaped numpy array of integer face indices into TrianglMesh.vertex_data.positions</li>
<li><code>normals</code>: [F, 3]-shaped numpy array of per-face normals (or None)</li>
<li><code>colors</code>: [F, 4]-shaped numpy array of per-face RBGA colors in [0.0, 1.0] (or None)</li>
<li><code>quality</code>: [F,]-shaped numpy array of per-face quality measures (or None)</li>
<li><code>flags</code>: [F,]-shaped numpy array of 32-bit integer flags per face (or None)</li>
<li><code>wedge_colors</code>: [F, 3, 4]-shaped numpy array of per-wedge RBGA colors in [0.0, 1.0] (or None)</li>
<li><code>wedge_normals</code>: [F, 3, 3]-shaped numpy array of per-wedge normals (or None)</li>
<li><code>wedge_texcoords</code>: [F, 3, 2]-shaped numpy array of per-wedge] uv coordinates (or None)</li>
<li><code>wedge_tex_ids</code>: [F, 3]-shaped numpy array of integer indices into TriangleMesh.textures indicating which texture to use at this wedge (or None)</li>
<li><code>textures</code>: A list of paths to texture image files for this mesh</li>
<li><code>normal_maps</code>: A list of paths to texture image files for this mesh</li>
</ul>



  

  <div class="doc doc-children">











  </div>

  </div>

</div>

<div class="doc doc-object doc-class">



<h3 id="point_cloud_utils._mesh_io.TriangleMesh.VertexData" class="doc doc-heading">
        <code>VertexData</code>


</h3>


  <div class="doc doc-contents ">

  
      <p>A lightweight container class representing per-vertex information within a TriangleMesh with the following attributes</p>
<ul>
<li><code>positions</code>: [V, 3]-shaped numpy array of per-vertex positions</li>
<li><code>normals</code>: [V, 3]-shaped numpy array of per-vertex normals (or None)</li>
<li><code>texcoords</code>: [V, 2]-shaped numpy array of per-vertex uv coordinates (or None)</li>
<li><code>tex_ids</code>: [V,]-shaped numpy array of integer indices into TriangleMesh.textures indicating which texture to use at this vertex (or None)</li>
<li><code>colors</code>: [V, 4]-shaped numpy array of per-vertex RBGA colors in [0.0, 1.0] (or None)</li>
<li><code>radius</code>: [V,]-shaped numpy array of per-vertex curvature radii (or None)</li>
<li><code>quality</code>: [V,]-shaped numpy array of per-vertex quality measures (or None)</li>
<li><code>flags</code>: [V,]-shaped numpy array of 32-bit integer flags per vertex (or None)</li>
</ul>



  

  <div class="doc doc-children">











  </div>

  </div>

</div>


<div class="doc doc-object doc-function">



<h3 id="point_cloud_utils._mesh_io.TriangleMesh.load" class="doc doc-heading">
<code class="highlight language-python"><span class="n">load</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span></code>

</h3>


  <div class="doc doc-contents ">
  
      <p>Load a mesh into this class from a file. The type of file is determined by the extension.
Point Cloud Utils currently supports PLY, OBJ, STL, OFF, VRML 2.0, X3D, COLLADA, 3DS.</p>

  <p><strong>Parameters:</strong></p>
  <table>
    <thead>
      <tr>
        <th>Name</th>
        <th>Type</th>
        <th>Description</th>
        <th>Default</th>
      </tr>
    </thead>
    <tbody>
        <tr>
          <td><code>filename</code></td>
          <td>
          </td>
          <td><p>Path to the file to be loaded. Must have a valid extension.</p></td>
          <td>
              <em>required</em>
          </td>
        </tr>
        <tr>
          <td><code>dtype</code></td>
          <td>
          </td>
          <td><p>Type to save floating point data in (defaults to np.float32)</p></td>
          <td>
                <code>np.float64</code>
          </td>
        </tr>
    </tbody>
  </table>

  </div>

</div>

<div class="doc doc-object doc-function">



<h3 id="point_cloud_utils._mesh_io.TriangleMesh.save" class="doc doc-heading">
<code class="highlight language-python"><span class="n">save</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span></code>

</h3>


  <div class="doc doc-contents ">
  
      <p>Save this mesh to a file. The type of file is determined by the extension. Point Cloud Utils currently supports PLY, OBJ, STL, OFF, VRML 2.0, X3D, COLLADA, 3DS.</p>

  <p><strong>Parameters:</strong></p>
  <table>
    <thead>
      <tr>
        <th>Name</th>
        <th>Type</th>
        <th>Description</th>
        <th>Default</th>
      </tr>
    </thead>
    <tbody>
        <tr>
          <td><code>filename</code></td>
          <td>
          </td>
          <td><p>Path to the file to be saved. Must have a valid extension.</p></td>
          <td>
              <em>required</em>
          </td>
        </tr>
        <tr>
          <td><code>dtype</code></td>
          <td>
          </td>
          <td><p>Type to save floating point data in (defaults to np.float32)</p></td>
          <td>
                <code>np.float32</code>
          </td>
        </tr>
    </tbody>
  </table>

  </div>

</div>



  </div>

  </div>

</div><hr />


<div class="doc doc-object doc-function">



<h2 id="point_cloud_utils.chamfer_distance" class="doc doc-heading">
<code class="highlight language-python"><span class="n">point_cloud_utils</span><span class="o">.</span><span class="n">chamfer_distance</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">return_index</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">p_norm</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">max_points_per_leaf</span><span class="o">=</span><span class="mi">10</span><span class="p">)</span></code>

</h2>


  <div class="doc doc-contents first">
  
      <p>Compute the chamfer distance between two point clouds x, and y</p>

  <p><strong>Parameters:</strong></p>
  <table>
    <thead>
      <tr>
        <th>Name</th>
        <th>Type</th>
        <th>Description</th>
        <th>Default</th>
      </tr>
    </thead>
    <tbody>
        <tr>
          <td><code>x</code></td>
          <td>
          </td>
          <td><p>A m-sized minibatch of point sets in R^d. i.e. shape [m, n_a, d]</p></td>
          <td>
              <em>required</em>
          </td>
        </tr>
        <tr>
          <td><code>y</code></td>
          <td>
          </td>
          <td><p>A m-sized minibatch of point sets in R^d. i.e. shape [m, n_b, d]</p></td>
          <td>
              <em>required</em>
          </td>
        </tr>
        <tr>
          <td><code>return_index</code></td>
          <td>
          </td>
          <td><p>If set to True, will return a pair (corrs_x_to_y, corrs_y_to_x) where
        corrs_x_to_y[i] stores the index into y of the closest point to x[i]
        (i.e. y[corrs_x_to_y[i]] is the nearest neighbor to x[i] in y).
        corrs_y_to_x is similar to corrs_x_to_y but with x and y reversed.</p></td>
          <td>
                <code>False</code>
          </td>
        </tr>
        <tr>
          <td><code>max_points_per_leaf</code></td>
          <td>
          </td>
          <td><p>The maximum number of points per leaf node in the KD tree used by this function.
                Default is 10.</p></td>
          <td>
                <code>10</code>
          </td>
        </tr>
        <tr>
          <td><code>p_norm</code></td>
          <td>
          </td>
          <td><p>Which norm to use. p_norm can be any real number, inf (for the max norm) -inf (for the min norm),
    0 (for sum(x != 0))</p></td>
          <td>
                <code>2</code>
          </td>
        </tr>
    </tbody>
  </table>

  <p><strong>Returns:</strong></p>
  <table>
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
        <tr>
          <td>
          </td>
          <td><p>The chamfer distance between x an dy.</p></td>
        </tr>
        <tr>
          <td>
          </td>
          <td><p>If return_index is set, then this function returns a tuple (chamfer_dist, corrs_x_to_y, corrs_y_to_x) where</p></td>
        </tr>
        <tr>
          <td>
          </td>
          <td><p>corrs_x_to_y and corrs_y_to_x are described above.</p></td>
        </tr>
    </tbody>
  </table>

  </div>

</div><hr />


<div class="doc doc-object doc-function">



<h2 id="point_cloud_utils.closest_points_on_mesh" class="doc doc-heading">
<code class="highlight language-python"><span class="n">point_cloud_utils</span><span class="o">.</span><span class="n">closest_points_on_mesh</span><span class="p">()</span></code>
  
  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-builtin"><code>builtin</code></small>
  </span>

</h2>


  <div class="doc doc-contents first">
  
      <p>closest_points_on_mesh(p: numpy.ndarray, v: numpy.ndarray, f: numpy.ndarray) -&gt; Tuple[object, object, object]</p>
<p>Compute distances from a set of points p to a triangle mesh (v, f)</p>

  <p><strong>Parameters:</strong></p>
  <table>
    <thead>
      <tr>
        <th>Name</th>
        <th>Type</th>
        <th>Description</th>
        <th>Default</th>
      </tr>
    </thead>
    <tbody>
        <tr>
          <td><code>p</code></td>
          <td>
          </td>
          <td><p>(#p, 3)-shaped array of query point positions</p></td>
          <td>
              <em>required</em>
          </td>
        </tr>
        <tr>
          <td><code>v</code></td>
          <td>
          </td>
          <td><p>(#v, 3)-shaped array of mesh vertex positions</p></td>
          <td>
              <em>required</em>
          </td>
        </tr>
        <tr>
          <td><code>f</code></td>
          <td>
          </td>
          <td><p>(#f, 3)-shaped array of triangle face indices</p></td>
          <td>
              <em>required</em>
          </td>
        </tr>
    </tbody>
  </table>

  <p><strong>Returns:</strong></p>
  <table>
    <thead>
      <tr>
<th>Name</th>        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
        <tr>
<td><code>d</code></td>          <td>
          </td>
          <td><p>a (#p,)-shaped array of shortest distances for each query point p</p></td>
        </tr>
        <tr>
<td><code>f_idx</code></td>          <td>
          </td>
          <td><p>a (#p,)-shaped array of indices into f of the face containing the closest point to eaach query point</p></td>
        </tr>
        <tr>
<td><code>bc</code></td>          <td>
          </td>
          <td><p>a (#p, 3)-shaped array of barycentric coordinates for each query point</p></td>
        </tr>
    </tbody>
  </table>

<details class="notes">
  <summary>Notes</summary>
  <p>Known bugs: This only computes distances to given primitives. So unreferenced vertices are ignored. However, degenerate primitives are handled correctly: triangle [1 2 2] is treated as a segment [1 2], and triangle [1 1 1] is treated as a point. So one <em>could</em> add extra combinatorially degenerate rows to Ele for all unreferenced vertices to also get distances to points.</p>
</details>
  </div>

</div><hr />


<div class="doc doc-object doc-function">



<h2 id="point_cloud_utils.connected_components" class="doc doc-heading">
<code class="highlight language-python"><span class="n">point_cloud_utils</span><span class="o">.</span><span class="n">connected_components</span><span class="p">()</span></code>
  
  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-builtin"><code>builtin</code></small>
  </span>

</h2>


  <div class="doc doc-contents first">
  
      <p>connected_components(v: numpy.ndarray, f: numpy.ndarray) -&gt; Tuple[object, object, object, object]</p>
<p>Determine the connected components of a mesh</p>

  <p><strong>Parameters:</strong></p>
  <table>
    <thead>
      <tr>
        <th>Name</th>
        <th>Type</th>
        <th>Description</th>
        <th>Default</th>
      </tr>
    </thead>
    <tbody>
        <tr>
          <td><code>v</code></td>
          <td>
          </td>
          <td><p>(#v, 3)-shaped array of mesh vertex positions (one vertex position per row)</p></td>
          <td>
              <em>required</em>
          </td>
        </tr>
        <tr>
          <td><code>f</code></td>
          <td>
          </td>
          <td><p>(#f, 3)-shaped array of mesh face indexes into v (a row (fi, fj, fk) indicate the 3 vertices of a face)</p></td>
          <td>
              <em>required</em>
          </td>
        </tr>
    </tbody>
  </table>

  <p><strong>Returns:</strong></p>
  <table>
    <thead>
      <tr>
<th>Name</th>        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
        <tr>
<td><code>cv</code></td>          <td>
          </td>
          <td><p>a (#vertices,)-shaped array of integer indexes (starting from 0) indicating which component each vertex belongs to. i.e. cv[i] is the component of the vertex v[i].</p></td>
        </tr>
        <tr>
<td><code>nv</code></td>          <td>
          </td>
          <td><p>the number of vertices in each connected component. i.e. nv[j] is the number of vertices in component j</p></td>
        </tr>
        <tr>
<td><code>cf</code></td>          <td>
          </td>
          <td><p>a (#faces,)-shaped array of integer indexes (starting from 0) indicating which component each face belongs to. i.e. cf[i] is the component of the face f[i].</p></td>
        </tr>
        <tr>
<td><code>nf</code></td>          <td>
          </td>
          <td><p>the number of faces in each connected component. i.e. nf[j] is the number of faces in component j</p></td>
        </tr>
    </tbody>
  </table>

  </div>

</div><hr />


<div class="doc doc-object doc-function">



<h2 id="point_cloud_utils.decimate_triangle_mesh" class="doc doc-heading">
<code class="highlight language-python"><span class="n">point_cloud_utils</span><span class="o">.</span><span class="n">decimate_triangle_mesh</span><span class="p">()</span></code>
  
  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-builtin"><code>builtin</code></small>
  </span>

</h2>


  <div class="doc doc-contents first">
  
      <p>decimate_triangle_mesh(v: numpy.ndarray, f: numpy.ndarray, max_faces: int, decimation_heuristic: str = 'shortest_edge') -&gt; Tuple[object, object, object, object]</p>
<p>Decimate a (manifold) triangle mesh by collapsing edges</p>

  <p><strong>Parameters:</strong></p>
  <table>
    <thead>
      <tr>
        <th>Name</th>
        <th>Type</th>
        <th>Description</th>
        <th>Default</th>
      </tr>
    </thead>
    <tbody>
        <tr>
          <td><code>v</code></td>
          <td>
          </td>
          <td><p>(#v, 3)-shaped array of mesh vertex positions</p></td>
          <td>
              <em>required</em>
          </td>
        </tr>
        <tr>
          <td><code>f</code></td>
          <td>
          </td>
          <td><p>(#f, 3)-shaped array of triangle face indices</p></td>
          <td>
              <em>required</em>
          </td>
        </tr>
        <tr>
          <td><code>max_faces</code></td>
          <td>
          </td>
          <td><p>The maximum number of faces in the decimated output mesh (must be between 0 and #f)</p></td>
          <td>
              <em>required</em>
          </td>
        </tr>
        <tr>
          <td><code>decimation_heuristic</code></td>
          <td>
          </td>
          <td><p>Which decimation heuristic to use. Currently only supports "shortest_edge".</p></td>
          <td>
              <em>required</em>
          </td>
        </tr>
    </tbody>
  </table>

  <p><strong>Returns:</strong></p>
  <table>
    <thead>
      <tr>
<th>Name</th>        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
        <tr>
<td><code>v_out</code></td>          <td>
          </td>
          <td><p>(#v_out, 3)-shaped array of vertex positions for the decimated mesh</p></td>
        </tr>
        <tr>
<td><code>f_out</code></td>          <td>
          </td>
          <td><p>(#f_out, 3)-shaped array of triangle face indices for the decimated mesh</p></td>
        </tr>
        <tr>
<td><code>v_correspondences</code></td>          <td>
          </td>
          <td><p>(#v_out, 1)-shaped array where v_correspondences[i] is the index of the vertex in v which generated v_out[i]</p></td>
        </tr>
        <tr>
<td><code>f_correspondences</code></td>          <td>
          </td>
          <td><p>(#f_out, 1)-shaped array where f_correspondences[i] is the index of the face in f which generated f_out[i]</p></td>
        </tr>
    </tbody>
  </table>

  </div>

</div><hr />


<div class="doc doc-object doc-function">



<h2 id="point_cloud_utils.deduplicate_mesh_vertices" class="doc doc-heading">
<code class="highlight language-python"><span class="n">point_cloud_utils</span><span class="o">.</span><span class="n">deduplicate_mesh_vertices</span><span class="p">()</span></code>
  
  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-builtin"><code>builtin</code></small>
  </span>

</h2>


  <div class="doc doc-contents first">
  
      <p>deduplicate_mesh_vertices(v: numpy.ndarray, f: numpy.ndarray, epsilon: float, return_index: bool = True) -&gt; object</p>
<p>Removes duplicated vertices from a triangle mesh two vertices are considered the same if their distance is below
some threshold</p>

  <p><strong>Parameters:</strong></p>
  <table>
    <thead>
      <tr>
        <th>Name</th>
        <th>Type</th>
        <th>Description</th>
        <th>Default</th>
      </tr>
    </thead>
    <tbody>
        <tr>
          <td><code>v</code></td>
          <td>
          </td>
          <td><p>#v by 3 Matrix of mesh vertex 3D positions</p></td>
          <td>
              <em>required</em>
          </td>
        </tr>
        <tr>
          <td><code>f</code></td>
          <td>
          </td>
          <td><p>#f by 3 Matrix of face (triangle) indices</p></td>
          <td>
              <em>required</em>
          </td>
        </tr>
        <tr>
          <td><code>epsilon</code></td>
          <td>
          </td>
          <td><p>threshold below which two points are considered equal</p></td>
          <td>
              <em>required</em>
          </td>
        </tr>
        <tr>
          <td><code>return_index</code></td>
          <td>
          </td>
          <td><p>If true, return indices to map between input and output</p></td>
          <td>
              <em>required</em>
          </td>
        </tr>
    </tbody>
  </table>

  <p><strong>Returns:</strong></p>
  <table>
    <thead>
      <tr>
<th>Name</th>        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
        <tr>
<td><code>x_new</code></td>          <td>
          </td>
          <td><p>#x_new x 3 Point cloud with duplicates removed</p></td>
        </tr>
        <tr>
<td><code>svi</code></td>          <td>
          </td>
          <td><p>#x x 1 indices so that x_new = x[svi] (only returned if return_index is True)</p></td>
        </tr>
        <tr>
<td><code>svj</code></td>          <td>
          </td>
          <td><p>#x_new x 1 indices so that x = x_new[svj] (only returned if return_index is True)</p></td>
        </tr>
    </tbody>
  </table>

<details class="see-also">
  <summary>See also</summary>
  <p>deduplicate_point_cloud</p>
</details>
  </div>

</div><hr />


<div class="doc doc-object doc-function">



<h2 id="point_cloud_utils.deduplicate_point_cloud" class="doc doc-heading">
<code class="highlight language-python"><span class="n">point_cloud_utils</span><span class="o">.</span><span class="n">deduplicate_point_cloud</span><span class="p">()</span></code>
  
  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-builtin"><code>builtin</code></small>
  </span>

</h2>


  <div class="doc doc-contents first">
  
      <p>deduplicate_point_cloud(points: numpy.ndarray, epsilon: float, return_index: bool = True) -&gt; object</p>
<p>Removes duplicated points from a point cloud where two points are considered the same if their distance is below
some threshold</p>

  <p><strong>Parameters:</strong></p>
  <table>
    <thead>
      <tr>
        <th>Name</th>
        <th>Type</th>
        <th>Description</th>
        <th>Default</th>
      </tr>
    </thead>
    <tbody>
        <tr>
          <td><code>x</code></td>
          <td>
          </td>
          <td><p>#x by 3 Matrix of 3D positions</p></td>
          <td>
              <em>required</em>
          </td>
        </tr>
        <tr>
          <td><code>epsilon</code></td>
          <td>
          </td>
          <td><p>threshold below which two points are considered equal</p></td>
          <td>
              <em>required</em>
          </td>
        </tr>
        <tr>
          <td><code>return_index</code></td>
          <td>
          </td>
          <td><p>If true, return indices to map between input and output</p></td>
          <td>
              <em>required</em>
          </td>
        </tr>
    </tbody>
  </table>

  <p><strong>Returns:</strong></p>
  <table>
    <thead>
      <tr>
<th>Name</th>        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
        <tr>
<td><code>x_new</code></td>          <td>
          </td>
          <td><p>#x_new x 3 Point cloud with duplicates removed</p></td>
        </tr>
        <tr>
<td></td>          <td>
          </td>
          <td><p>if return indices is set, this function also returns:
svi : #x x 1 indices so that x_new = x[svi]
svj : #x_new x 1 indices so that x = x_new[svj]</p></td>
        </tr>
    </tbody>
  </table>

<details class="see-also">
  <summary>See also</summary>
  <p>deduplicate_mesh_vertices</p>
</details>
  </div>

</div><hr />


<div class="doc doc-object doc-function">



<h2 id="point_cloud_utils.dilate_sparse_voxel_grid" class="doc doc-heading">
<code class="highlight language-python"><span class="n">point_cloud_utils</span><span class="o">.</span><span class="n">dilate_sparse_voxel_grid</span><span class="p">(</span><span class="n">grid_coordinates</span><span class="p">,</span> <span class="n">count</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span></code>

</h2>


  <div class="doc doc-contents first">
  
      <p>Perform binary dilation on a sparse voxel grid, using a 3x3 filter of ones applied count times.
i.e. convolve the filter:
    [[1, 1, 1],
     [1, 1, 1],
     [1, 1, 1]]
with the sparse voxel grid.</p>

  <p><strong>Parameters:</strong></p>
  <table>
    <thead>
      <tr>
        <th>Name</th>
        <th>Type</th>
        <th>Description</th>
        <th>Default</th>
      </tr>
    </thead>
    <tbody>
        <tr>
          <td><code>grid_coordinates</code></td>
          <td>
          </td>
          <td><p>An (n, 3) shaped integer array of voxels coordinates in the sparse voxel grid</p></td>
          <td>
              <em>required</em>
          </td>
        </tr>
        <tr>
          <td><code>count</code></td>
          <td>
          </td>
          <td><p>The number of iterations of binary dilation to run</p></td>
          <td>
                <code>1</code>
          </td>
        </tr>
    </tbody>
  </table>

  <p><strong>Returns:</strong></p>
  <table>
    <thead>
      <tr>
<th>Name</th>        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
        <tr>
<td><code>dilated_grid_coordinates</code></td>          <td>
          </td>
          <td><p>An (m, 3) integer array encoding the coordinates of the sparse voxel grid after dilation</p></td>
        </tr>
    </tbody>
  </table>

  </div>

</div><hr />


<div class="doc doc-object doc-function">



<h2 id="point_cloud_utils.downsample_point_cloud_on_voxel_grid" class="doc doc-heading">
<code class="highlight language-python"><span class="n">point_cloud_utils</span><span class="o">.</span><span class="n">downsample_point_cloud_on_voxel_grid</span><span class="p">(</span><span class="n">voxel_size</span><span class="p">,</span> <span class="n">points</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="n">min_bound</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">max_bound</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">min_points_per_voxel</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span></code>

</h2>


  <div class="doc doc-contents first">
  
      <p>Downsample a point set to conform with a voxel grid by taking the average of points within each voxel.</p>

  <p><strong>Parameters:</strong></p>
  <table>
    <thead>
      <tr>
        <th>Name</th>
        <th>Type</th>
        <th>Description</th>
        <th>Default</th>
      </tr>
    </thead>
    <tbody>
        <tr>
          <td><code>voxel_size</code></td>
          <td>
          </td>
          <td><p>a scalar representing the size of each voxel or a 3 tuple representing the size per axis of each voxel.</p></td>
          <td>
              <em>required</em>
          </td>
        </tr>
        <tr>
          <td><code>points</code></td>
          <td>
          </td>
          <td><p>a [#v, 3]-shaped array of 3d points.</p></td>
          <td>
              <em>required</em>
          </td>
        </tr>
        <tr>
          <td><code>*args</code></td>
          <td>
          </td>
          <td><p>Any additional arguments of shape [#v, *] are treated as attributes and will averaged into each voxel along with the points
These will be returns</p></td>
          <td>
                <code>()</code>
          </td>
        </tr>
        <tr>
          <td><code>min_bound</code></td>
          <td>
          </td>
          <td><p>a 3 tuple representing the minimum coordinate of the voxel grid or None to use the bounding box of the
    input point cloud.</p></td>
          <td>
                <code>None</code>
          </td>
        </tr>
        <tr>
          <td><code>max_bound</code></td>
          <td>
          </td>
          <td><p>a 3 tuple representing the maximum coordinate of the voxel grid or None to use the bounding box of the
    input point cloud.</p></td>
          <td>
                <code>None</code>
          </td>
        </tr>
        <tr>
          <td><code>min_points_per_voxel</code></td>
          <td>
          </td>
          <td><p>If a voxel contains fewer than this many points, then don't include the points in that voxel
                in the output.</p></td>
          <td>
                <code>1</code>
          </td>
        </tr>
    </tbody>
  </table>

  <p><strong>Returns:</strong></p>
  <table>
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
        <tr>
          <td>
          </td>
          <td><p>A tuple (v, attrib0, attrib1, ....) of downsampled points, and point attributes.</p></td>
        </tr>
        <tr>
          <td>
          </td>
          <td><p>Attributes are returned in the same order they are passed in.</p></td>
        </tr>
        <tr>
          <td>
          </td>
          <td><p>If no attributes are passed in, then this function simply returns vertices.</p></td>
        </tr>
    </tbody>
  </table>

  </div>

</div><hr />


<div class="doc doc-object doc-function">



<h2 id="point_cloud_utils.downsample_point_cloud_poisson_disk" class="doc doc-heading">
<code class="highlight language-python"><span class="n">point_cloud_utils</span><span class="o">.</span><span class="n">downsample_point_cloud_poisson_disk</span><span class="p">()</span></code>
  
  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-builtin"><code>builtin</code></small>
  </span>

</h2>


  <div class="doc doc-contents first">
  
      <p>downsample_point_cloud_poisson_disk(v: numpy.ndarray, num_samples: int, radius: float = 0.0, best_choice_sampling: bool = True, random_seed: int = 0, sample_num_tolerance: float = 0.04) -&gt; object</p>
<p>Downsample a point set so that samples are approximately evenly spaced.
This function uses the method in "Parallel Poisson Disk Sampling with Spectrum Analysis on Surface"
(http://graphics.cs.umass.edu/pubs/sa_2010.pdf)</p>

  <p><strong>Parameters:</strong></p>
  <table>
    <thead>
      <tr>
        <th>Name</th>
        <th>Type</th>
        <th>Description</th>
        <th>Default</th>
      </tr>
    </thead>
    <tbody>
        <tr>
          <td><code>v</code></td>
          <td>
          </td>
          <td><p>#v by 3 array of vertex positions</p></td>
          <td>
              <em>required</em>
          </td>
        </tr>
        <tr>
          <td><code>n</code></td>
          <td>
          </td>
          <td><p>#v by 3 array of vertex normals</p></td>
          <td>
              <em>required</em>
          </td>
        </tr>
        <tr>
          <td><code>num_samples</code></td>
          <td>
          </td>
          <td><p>desired number of Poisson Disk samples. Note that the actual number of returned samples will not be exactly this value (see sample_num_tolerance) to control the range of possible returned samples. Note: If this value &lt;= 0, then the parameter radius is used to decide the number of samples</p></td>
          <td>
              <em>required</em>
          </td>
        </tr>
        <tr>
          <td><code>radius</code></td>
          <td>
          </td>
          <td><p>desired separation between points, if num_samples &lt;= 0, then this value is used to determine the sampling (-1.0, by default).</p></td>
          <td>
              <em>required</em>
          </td>
        </tr>
        <tr>
          <td><code>best_choice_sampling</code></td>
          <td>
          </td>
          <td><p>When downsampling, always keep the sample that will remove the fewest number of samples. (True by default).</p></td>
          <td>
              <em>required</em>
          </td>
        </tr>
        <tr>
          <td><code>random_seed</code></td>
          <td>
          </td>
          <td><p>A random seed used to generate the samples. Passing in 0 will use the current time. (0 by default).</p></td>
          <td>
              <em>required</em>
          </td>
        </tr>
        <tr>
          <td><code>sample_num_tolerance</code></td>
          <td>
          </td>
          <td><p>If you requested a target number of samples, by passsing num_samples &gt; 0, then this function will return between (1 - sample_num_tolerance) * num_samples and (1 + sample_num_tolerance) * num_samples. Setting a very small value for this parameter will increase convergence time. (0.04 by default).</p></td>
          <td>
              <em>required</em>
          </td>
        </tr>
    </tbody>
  </table>

  <p><strong>Returns:</strong></p>
  <table>
    <thead>
      <tr>
<th>Name</th>        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
        <tr>
<td><code>p_idx</code></td>          <td>
          </td>
          <td><p>A (m,) shaped array of indices into v where m is the number of Poisson-disk samples</p></td>
        </tr>
    </tbody>
  </table>

  </div>

</div><hr />


<div class="doc doc-object doc-function">



<h2 id="point_cloud_utils.earth_movers_distance" class="doc doc-heading">
<code class="highlight language-python"><span class="n">point_cloud_utils</span><span class="o">.</span><span class="n">earth_movers_distance</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">q</span><span class="p">,</span> <span class="n">p_norm</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">eps</span><span class="o">=</span><span class="mf">0.0001</span><span class="p">,</span> <span class="n">max_iters</span><span class="o">=</span><span class="mi">100</span><span class="p">,</span> <span class="n">stop_thresh</span><span class="o">=</span><span class="mf">0.001</span><span class="p">)</span></code>

</h2>


  <div class="doc doc-contents first">
  
      <p>Compute the (batched) Sinkhorn correspondences between two dirac delta distributions, U, and V.
This implementation is numerically stable with float32.</p>

  <p><strong>Parameters:</strong></p>
  <table>
    <thead>
      <tr>
        <th>Name</th>
        <th>Type</th>
        <th>Description</th>
        <th>Default</th>
      </tr>
    </thead>
    <tbody>
        <tr>
          <td><code>p</code></td>
          <td>
          </td>
          <td><p>An (n, d)-shaped array of d-dimensional points</p></td>
          <td>
              <em>required</em>
          </td>
        </tr>
        <tr>
          <td><code>b</code></td>
          <td>
          </td>
          <td><p>An (m, d)-shaped array of d-dimensional points</p></td>
          <td>
              <em>required</em>
          </td>
        </tr>
        <tr>
          <td><code>p_norm</code></td>
          <td>
          </td>
          <td><p>Which norm to use. Must be one of {non-zero int, inf, -inf, fro, nuc} (default is 2),</p></td>
          <td>
                <code>2</code>
          </td>
        </tr>
        <tr>
          <td><code>eps</code></td>
          <td>
          </td>
          <td><p>The reciprocal of the sinkhorn regularization parameter (default 1e-4)</p></td>
          <td>
                <code>0.0001</code>
          </td>
        </tr>
        <tr>
          <td><code>max_iters</code></td>
          <td>
          </td>
          <td><p>The maximum number of Sinkhorn iterations</p></td>
          <td>
                <code>100</code>
          </td>
        </tr>
        <tr>
          <td><code>stop_thresh</code></td>
          <td>
          </td>
          <td><p>Stop if the change in iterates is below this value</p></td>
          <td>
                <code>0.001</code>
          </td>
        </tr>
    </tbody>
  </table>

  <p><strong>Returns:</strong></p>
  <table>
    <thead>
      <tr>
<th>Name</th>        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
        <tr>
<td><code>emd</code></td>          <td>
          </td>
          <td><p>The earth mover's distance between point clouds p and q</p></td>
        </tr>
        <tr>
<td><code>P</code></td>          <td>
          </td>
          <td><p>An (n, m)-shaped array of correspondences between point clouds p and q</p></td>
        </tr>
    </tbody>
  </table>

  </div>

</div><hr />


<div class="doc doc-object doc-function">



<h2 id="point_cloud_utils.erode_sparse_voxel_grid" class="doc doc-heading">
<code class="highlight language-python"><span class="n">point_cloud_utils</span><span class="o">.</span><span class="n">erode_sparse_voxel_grid</span><span class="p">(</span><span class="n">grid_coordinates</span><span class="p">,</span> <span class="n">count</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span></code>

</h2>


  <div class="doc doc-contents first">
  
      <p>Perform binary erosion on a sparse voxel grid, using a 3x3 filter of ones applied count times.
i.e. take the negation of the convolution of the filter:
    [[1, 1, 1],
     [1, 1, 1],
     [1, 1, 1]]
with the sparse voxel grid.</p>

  <p><strong>Parameters:</strong></p>
  <table>
    <thead>
      <tr>
        <th>Name</th>
        <th>Type</th>
        <th>Description</th>
        <th>Default</th>
      </tr>
    </thead>
    <tbody>
        <tr>
          <td><code>grid_coordinates</code></td>
          <td>
          </td>
          <td><p>An (n, 3) shaped integer array of voxels coordinates in the sparse voxel grid</p></td>
          <td>
              <em>required</em>
          </td>
        </tr>
        <tr>
          <td><code>count</code></td>
          <td>
          </td>
          <td><p>The number of iterations of binary erosion to run</p></td>
          <td>
                <code>1</code>
          </td>
        </tr>
    </tbody>
  </table>

  <p><strong>Returns:</strong></p>
  <table>
    <thead>
      <tr>
<th>Name</th>        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
        <tr>
<td><code>eroded_grid_coordinates</code></td>          <td>
          </td>
          <td><p>An (m, 3) integer array encoding the coordinates of the sparse voxel grid after erosion</p></td>
        </tr>
    </tbody>
  </table>

  </div>

</div><hr />


<div class="doc doc-object doc-function">



<h2 id="point_cloud_utils.estimate_mesh_face_normals" class="doc doc-heading">
<code class="highlight language-python"><span class="n">point_cloud_utils</span><span class="o">.</span><span class="n">estimate_mesh_face_normals</span><span class="p">()</span></code>
  
  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-builtin"><code>builtin</code></small>
  </span>

</h2>


  <div class="doc doc-contents first">
  
      <p>estimate_mesh_face_normals(v: numpy.ndarray, f: numpy.ndarray) -&gt; object</p>
<p>Compute vertex normals of a mesh from its vertices and faces using face area weighting</p>

  <p><strong>Parameters:</strong></p>
  <table>
    <thead>
      <tr>
        <th>Name</th>
        <th>Type</th>
        <th>Description</th>
        <th>Default</th>
      </tr>
    </thead>
    <tbody>
        <tr>
          <td><code>v</code></td>
          <td>
          </td>
          <td><p>(#v, 3)-shaped NumPy array of mesh vertex 3D positions</p></td>
          <td>
              <em>required</em>
          </td>
        </tr>
        <tr>
          <td><code>f</code></td>
          <td>
          </td>
          <td><p>(#f, 3)-shaped NumPy array of face (triangle) indices</p></td>
          <td>
              <em>required</em>
          </td>
        </tr>
    </tbody>
  </table>

  <p><strong>Returns:</strong></p>
  <table>
    <thead>
      <tr>
<th>Name</th>        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
        <tr>
<td><code>n</code></td>          <td>
          </td>
          <td><p>(#f, 3)-shaped NumPy array of face normals (i.e. n[i] is the normal at face f[i]). Note that any degenerate faces will have a zero normal.</p></td>
        </tr>
    </tbody>
  </table>

  </div>

</div><hr />


<div class="doc doc-object doc-function">



<h2 id="point_cloud_utils.estimate_mesh_vertex_normals" class="doc doc-heading">
<code class="highlight language-python"><span class="n">point_cloud_utils</span><span class="o">.</span><span class="n">estimate_mesh_vertex_normals</span><span class="p">()</span></code>
  
  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-builtin"><code>builtin</code></small>
  </span>

</h2>


  <div class="doc doc-contents first">
  
      <p>estimate_mesh_vertex_normals(v: numpy.ndarray, f: numpy.ndarray, weighting_type: str = 'uniform') -&gt; object</p>
<p>Compute vertex normals of a mesh from its vertices and faces using face area weighting</p>

  <p><strong>Parameters:</strong></p>
  <table>
    <thead>
      <tr>
        <th>Name</th>
        <th>Type</th>
        <th>Description</th>
        <th>Default</th>
      </tr>
    </thead>
    <tbody>
        <tr>
          <td><code>v</code></td>
          <td>
          </td>
          <td><p>(#v, 3)-shaped NumPy array of mesh vertex 3D positions</p></td>
          <td>
              <em>required</em>
          </td>
        </tr>
        <tr>
          <td><code>f</code></td>
          <td>
          </td>
          <td><p>(#f, 3)-shaped NumPy array of face (triangle) indices</p></td>
          <td>
              <em>required</em>
          </td>
        </tr>
        <tr>
          <td><code>weighting_type</code></td>
          <td>
          </td>
          <td><p>Weighting type must be one of 'uniform', 'angle', or 'area' (default is 'uniform')</p></td>
          <td>
              <em>required</em>
          </td>
        </tr>
    </tbody>
  </table>

  <p><strong>Returns:</strong></p>
  <table>
    <thead>
      <tr>
<th>Name</th>        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
        <tr>
<td><code>n</code></td>          <td>
          </td>
          <td><p>(#v, 3)-shaped NumPy array of vertex normals (i.e. n[i] is the normal at vertex v[i]) estimate_mesh_face_normals</p></td>
        </tr>
    </tbody>
  </table>

  </div>

</div><hr />


<div class="doc doc-object doc-function">



<h2 id="point_cloud_utils.estimate_point_cloud_normals_ball" class="doc doc-heading">
<code class="highlight language-python"><span class="n">point_cloud_utils</span><span class="o">.</span><span class="n">estimate_point_cloud_normals_ball</span><span class="p">(</span><span class="n">points</span><span class="p">,</span> <span class="n">ball_radius</span><span class="p">,</span> <span class="n">view_directions</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">drop_angle_threshold</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">deg2rad</span><span class="p">(</span><span class="mf">90.0</span><span class="p">),</span> <span class="n">min_pts_per_ball</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">max_pts_per_ball</span><span class="o">=-</span><span class="mi">1</span><span class="p">,</span> <span class="n">weight_function</span><span class="o">=</span><span class="s1">&#39;constant&#39;</span><span class="p">,</span> <span class="n">max_points_per_leaf</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span> <span class="n">num_threads</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span></code>

</h2>


  <div class="doc doc-contents first">
  
      <p>Estimate normals for a point cloud by locally fitting a plane to all points within a radius of each point
(possibly weighted by a radial basis function).</p>
<p>This function can optionally consider directions to the sensor for each point to compute neighborhoods of points
which are all facing the same direction, and align the final normal directions.</p>

  <p><strong>Parameters:</strong></p>
  <table>
    <thead>
      <tr>
        <th>Name</th>
        <th>Type</th>
        <th>Description</th>
        <th>Default</th>
      </tr>
    </thead>
    <tbody>
        <tr>
          <td><code>points</code></td>
          <td>
          </td>
          <td><p>(n, 3)-shaped NumPy array of point positions (each row is a point)</p></td>
          <td>
              <em>required</em>
          </td>
        </tr>
        <tr>
          <td><code>ball_radius</code></td>
          <td>
          </td>
          <td><p>The radius of each neighborhood used to estimate normals</p></td>
          <td>
              <em>required</em>
          </td>
        </tr>
        <tr>
          <td><code>view_directions</code></td>
          <td>
          </td>
          <td><p>(n, 3)-shaped NumPy array or None, representing the unit direction to the sensor for each point.
            This parameter is used to align the normals and compute neighborhoods of similar facing points.</p></td>
          <td>
                <code>None</code>
          </td>
        </tr>
        <tr>
          <td><code>drop_angle_threshold</code></td>
          <td>
          </td>
          <td><p>If view_directions is passed in, drop points whose angle between the normal and view direction
                exceeds drop_angle_threshold (in radians). Useful for filtering out low quality points.</p></td>
          <td>
                <code>np.deg2rad(90.0)</code>
          </td>
        </tr>
        <tr>
          <td><code>min_pts_per_ball</code></td>
          <td>
          </td>
          <td><p>Discard points whose neighborhood contains fewer than min_pts_per_ball points.</p></td>
          <td>
                <code>3</code>
          </td>
        </tr>
        <tr>
          <td><code>max_pts_per_ball</code></td>
          <td>
          </td>
          <td><p>If set to a positive number, then only use max_pts_per_ball points within each neighborhood
            whose number of points exceeds this value.</p></td>
          <td>
                <code>-1</code>
          </td>
        </tr>
        <tr>
          <td><code>weight_function</code></td>
          <td>
          </td>
          <td><p>Weighting function for points in a neighborhood. Must be one of 'constant' or 'rbf' where:</p></td>
          <td>
                <code>&#39;constant&#39;</code>
          </td>
        </tr>
        <tr>
          <td><code>max_points_per_leaf</code></td>
          <td>
          </td>
          <td><p>Maximum number of points in each leaf node of the KD-tree used for nearest neighbor queries.
                Tuning this can potentially improve performance on large point clouds.</p></td>
          <td>
                <code>10</code>
          </td>
        </tr>
        <tr>
          <td><code>num_threads</code></td>
          <td>
          </td>
          <td><p>Number of threads used to parallelize computation. If set to 0 ir 1, will run in single threaded mode.
        If set to a positive number t &gt; 1, will use t threads.
        If set to -1, will use #processors threads for inputs greater than 1 million points.</p></td>
          <td>
                <code>-1</code>
          </td>
        </tr>
    </tbody>
  </table>

  <p><strong>Returns:</strong></p>
  <table>
    <thead>
      <tr>
<th>Name</th>        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
        <tr>
<td><code>p</code></td>          <td>
          </td>
          <td><p>an (m, 3)-shaped Numpy array of 3d points</p></td>
        </tr>
        <tr>
<td><code>n</code></td>          <td>
          </td>
          <td><p>an (m, 3)-shaped Numpy array of unit normals for each point in p</p></td>
        </tr>
    </tbody>
  </table>

<details class="see-also">
  <summary>See Also</summary>
  <p>estimate_pointcloud_normals_ball</p>
</details>
  </div>

</div><hr />


<div class="doc doc-object doc-function">



<h2 id="point_cloud_utils.estimate_point_cloud_normals_knn" class="doc doc-heading">
<code class="highlight language-python"><span class="n">point_cloud_utils</span><span class="o">.</span><span class="n">estimate_point_cloud_normals_knn</span><span class="p">(</span><span class="n">points</span><span class="p">,</span> <span class="n">num_neighbors</span><span class="p">,</span> <span class="n">view_directions</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">drop_angle_threshold</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">deg2rad</span><span class="p">(</span><span class="mf">90.0</span><span class="p">),</span> <span class="n">max_points_per_leaf</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span> <span class="n">num_threads</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span></code>

</h2>


  <div class="doc doc-contents first">
  
      <p>Estimate normals for a point cloud by locally fitting a plane to the k nearest neighbors of each point.</p>
<p>This function can optionally consider directions to the sensor for each point to compute neighborhoods of points
which are all facing the same direction, and align the final normal directions.</p>

  <p><strong>Parameters:</strong></p>
  <table>
    <thead>
      <tr>
        <th>Name</th>
        <th>Type</th>
        <th>Description</th>
        <th>Default</th>
      </tr>
    </thead>
    <tbody>
        <tr>
          <td><code>points</code></td>
          <td>
          </td>
          <td><p>(n, 3)-shaped NumPy array of point positions (each row is a point)</p></td>
          <td>
              <em>required</em>
          </td>
        </tr>
        <tr>
          <td><code>num_neighbors</code></td>
          <td>
          </td>
          <td><p>Integer number of neighbors to use in each neigghborhood.</p></td>
          <td>
              <em>required</em>
          </td>
        </tr>
        <tr>
          <td><code>view_directions</code></td>
          <td>
          </td>
          <td><p>(n, 3)-shaped NumPy array or None, representing the unit direction to the sensor for each point. This parameter is used to align the normals and compute neighborhoods of similar facing points.</p></td>
          <td>
                <code>None</code>
          </td>
        </tr>
        <tr>
          <td><code>drop_angle_threshold</code></td>
          <td>
          </td>
          <td><p>If view_directions is passed in, drop points whose angle between the normal and view direction exceeds drop_angle_threshold (in radians). Useful for filtering out low quality points.</p></td>
          <td>
                <code>np.deg2rad(90.0)</code>
          </td>
        </tr>
        <tr>
          <td><code>max_points_per_leaf</code></td>
          <td>
          </td>
          <td><p>Maximum number of points in each leaf node of the KD-tree used for nearest neighbor queries. Tuning this can potentially improve performance on large point clouds.</p></td>
          <td>
                <code>10</code>
          </td>
        </tr>
        <tr>
          <td><code>num_threads</code></td>
          <td>
          </td>
          <td><p>Number of threads used to parallelize computation. If set to 0 ir 1, will run in single threaded mode. If set to a positive number t &gt; 1, will use t threads. If set to -1, will use #processors threads for inputs greater than 1 million points.</p></td>
          <td>
                <code>-1</code>
          </td>
        </tr>
    </tbody>
  </table>

  <p><strong>Returns:</strong></p>
  <table>
    <thead>
      <tr>
<th>Name</th>        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
        <tr>
<td><code>idx</code></td>          <td>
          </td>
          <td><p>an (m, 1)-shaped Numpy array of indices into points</p></td>
        </tr>
        <tr>
<td><code>n</code></td>          <td>
          </td>
          <td><p>an (m, 3)-shaped Numpy array of unit normals for each point in p</p></td>
        </tr>
    </tbody>
  </table>

<details class="see-also">
  <summary>See Also</summary>
  <p>estimate_pointcloud_normals_ball</p>
</details>
  </div>

</div><hr />


<div class="doc doc-object doc-function">



<h2 id="point_cloud_utils.hausdorff_distance" class="doc doc-heading">
<code class="highlight language-python"><span class="n">point_cloud_utils</span><span class="o">.</span><span class="n">hausdorff_distance</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">return_index</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">squared_distances</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">max_points_per_leaf</span><span class="o">=</span><span class="mi">10</span><span class="p">)</span></code>

</h2>


  <div class="doc doc-contents first">
  
      <p>Compute the Hausdorff distance between x and y</p>

  <p><strong>Parameters:</strong></p>
  <table>
    <thead>
      <tr>
        <th>Name</th>
        <th>Type</th>
        <th>Description</th>
        <th>Default</th>
      </tr>
    </thead>
    <tbody>
        <tr>
          <td><code>x</code></td>
          <td>
          </td>
          <td><p>n by 3 array of representing a set of n points (each row is a point of dimension 3)</p></td>
          <td>
              <em>required</em>
          </td>
        </tr>
        <tr>
          <td><code>y</code></td>
          <td>
          </td>
          <td><p>m by 3 array of representing a set of m points (each row is a point of dimension 3)</p></td>
          <td>
              <em>required</em>
          </td>
        </tr>
        <tr>
          <td><code>return_index</code></td>
          <td>
          </td>
          <td><p>Optionally return the index pair <code>(i, j)</code> into x and y such that <code>x[i, :]</code> and <code>y[j, :]</code> are the two points with maximum shortest distance.</p></td>
          <td>
                <code>False</code>
          </td>
        </tr>
        <tr>
          <td><code>squared_distances</code></td>
          <td>
          </td>
          <td><p>If set to True, then return squared L2 distances. Default is False.</p></td>
          <td>
                <code>False</code>
          </td>
        </tr>
        <tr>
          <td><code>max_points_per_leaf</code></td>
          <td>
          </td>
          <td><p>The maximum number of points per leaf node in the KD tree used by this function. Default is 10.</p></td>
          <td>
                <code>10</code>
          </td>
        </tr>
    </tbody>
  </table>

  <p><strong>Returns:</strong></p>
  <table>
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
        <tr>
          <td>
          </td>
          <td><p>The largest shortest distance, <code>d</code> between each point in <code>source</code> and the points in <code>target</code>.</p></td>
        </tr>
        <tr>
          <td>
          </td>
          <td><p>If <code>return_index</code> is set, then this function returns a tuple (d, i, j) where <code>d</code> is as described above</p></td>
        </tr>
        <tr>
          <td>
          </td>
          <td><p>and <code>(i, j)</code> are such that <code>source[i, :]</code> and <code>target[j, :]</code> are the two points with maximum shortest</p></td>
        </tr>
        <tr>
          <td>
          </td>
          <td><p>distance.</p></td>
        </tr>
    </tbody>
  </table>

  </div>

</div><hr />


<div class="doc doc-object doc-function">



<h2 id="point_cloud_utils.interpolate_barycentric_coords" class="doc doc-heading">
<code class="highlight language-python"><span class="n">point_cloud_utils</span><span class="o">.</span><span class="n">interpolate_barycentric_coords</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">fi</span><span class="p">,</span> <span class="n">bc</span><span class="p">,</span> <span class="n">attribute</span><span class="p">)</span></code>

</h2>


  <div class="doc doc-contents first">
  
      <p>Interpolate an attribute stored at each vertex of a mesh across the faces of a triangle mesh using
barycentric coordinates</p>

  <p><strong>Parameters:</strong></p>
  <table>
    <thead>
      <tr>
        <th>Name</th>
        <th>Type</th>
        <th>Description</th>
        <th>Default</th>
      </tr>
    </thead>
    <tbody>
        <tr>
          <td><code>f</code></td>
          <td>
          </td>
          <td><p>a (#faces, 3)-shaped NumPy array of mesh faces (indexing into some vertex array).</p></td>
          <td>
              <em>required</em>
          </td>
        </tr>
        <tr>
          <td><code>fi</code></td>
          <td>
          </td>
          <td><p>a (#attribs,)-shaped NumPy array of indexes into f indicating which face each attribute lies within.</p></td>
          <td>
              <em>required</em>
          </td>
        </tr>
        <tr>
          <td><code>bc</code></td>
          <td>
          </td>
          <td><p>a (#attribs, 3)-shaped NumPy array of barycentric coordinates for each attribute</p></td>
          <td>
              <em>required</em>
          </td>
        </tr>
        <tr>
          <td><code>attribute</code></td>
          <td>
          </td>
          <td><p>a (#vertices, dim)-shaped NumPy array of attributes at each of the mesh vertices</p></td>
          <td>
              <em>required</em>
          </td>
        </tr>
    </tbody>
  </table>

  <p><strong>Returns:</strong></p>
  <table>
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
        <tr>
          <td>
          </td>
          <td><p>A (#attribs, dim)-shaped array of interpolated attributes.</p></td>
        </tr>
    </tbody>
  </table>

  </div>

</div><hr />


<div class="doc doc-object doc-function">



<h2 id="point_cloud_utils.k_nearest_neighbors" class="doc doc-heading">
<code class="highlight language-python"><span class="n">point_cloud_utils</span><span class="o">.</span><span class="n">k_nearest_neighbors</span><span class="p">()</span></code>
  
  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-builtin"><code>builtin</code></small>
  </span>

</h2>


  <div class="doc doc-contents first">
  
      <p>k_nearest_neighbors(query_points: numpy.ndarray, dataset_points: numpy.ndarray, k: int, squared_distances: bool = False, max_points_per_leaf: int = 10, num_threads: int = -1) -&gt; Tuple[object, object]</p>
<p>Compute the k nearest neighbors (L2 distance) from each point in the query point cloud to the dataset point cloud.</p>

  <p><strong>Parameters:</strong></p>
  <table>
    <thead>
      <tr>
        <th>Name</th>
        <th>Type</th>
        <th>Description</th>
        <th>Default</th>
      </tr>
    </thead>
    <tbody>
        <tr>
          <td><code>query_points</code></td>
          <td>
          </td>
          <td><p>n by 3 array of representing a set of n points (each row is a point of dimension 3).</p></td>
          <td>
              <em>required</em>
          </td>
        </tr>
        <tr>
          <td><code>dataset_points</code></td>
          <td>
          </td>
          <td><p>m by 3 array of representing a set of m points (each row is a point of dimension 3).</p></td>
          <td>
              <em>required</em>
          </td>
        </tr>
        <tr>
          <td><code>k</code></td>
          <td>
          </td>
          <td><p>the number of nearest neighbors to query per point.</p></td>
          <td>
              <em>required</em>
          </td>
        </tr>
        <tr>
          <td><code>squared_distances</code></td>
          <td>
          </td>
          <td><p>If set to True, then return squared L2 distances. Default is False.</p></td>
          <td>
              <em>required</em>
          </td>
        </tr>
        <tr>
          <td><code>max_points_per_leaf</code></td>
          <td>
          </td>
          <td><p>The maximum number of points per leaf node in the KD tree used by this function. Default is 10.</p></td>
          <td>
              <em>required</em>
          </td>
        </tr>
        <tr>
          <td><code>num_threads</code></td>
          <td>
          </td>
          <td><p>Number of threads to use. If set to -1, will use all available CPUs. If set to 0, will run in serial. Default is -1.</p></td>
          <td>
              <em>required</em>
          </td>
        </tr>
    </tbody>
  </table>

  <p><strong>Returns:</strong></p>
  <table>
    <thead>
      <tr>
<th>Name</th>        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
        <tr>
<td><code>dists</code></td>          <td>
          </td>
          <td><p>An (n, k)-shaped array such that <code>dists[i,k]</code> contains the k^th shortest L2 distance from the point <code>query_points[i, :]</code> to <code>dataset_points</code></p></td>
        </tr>
        <tr>
<td><code>corrs</code></td>          <td>
          </td>
          <td><p>An (n, k)-shaped array such that <code>corrs[i,k]</code> contains the index into <code>dataset_points</code> of the k^th nearest point to <code>query_points[i, :]</code></p></td>
        </tr>
    </tbody>
  </table>

  </div>

</div><hr />


<div class="doc doc-object doc-function">



<h2 id="point_cloud_utils.laplacian_smooth_mesh" class="doc doc-heading">
<code class="highlight language-python"><span class="n">point_cloud_utils</span><span class="o">.</span><span class="n">laplacian_smooth_mesh</span><span class="p">()</span></code>
  
  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-builtin"><code>builtin</code></small>
  </span>

</h2>


  <div class="doc doc-contents first">
  
      <p>laplacian_smooth_mesh(v: numpy.ndarray, f: numpy.ndarray, num_iters: int, use_cotan_weights: bool = False) -&gt; object</p>
<p>Smooth a mesh using Laplacian smoothing</p>

  <p><strong>Parameters:</strong></p>
  <table>
    <thead>
      <tr>
        <th>Name</th>
        <th>Type</th>
        <th>Description</th>
        <th>Default</th>
      </tr>
    </thead>
    <tbody>
        <tr>
          <td><code>v</code></td>
          <td>
          </td>
          <td><p>#v by 3 Matrix of mesh vertex 3D positions</p></td>
          <td>
              <em>required</em>
          </td>
        </tr>
        <tr>
          <td><code>f</code></td>
          <td>
          </td>
          <td><p>#f by 3 Matrix of face (triangle) indices</p></td>
          <td>
              <em>required</em>
          </td>
        </tr>
        <tr>
          <td><code>num_iters</code></td>
          <td>
          </td>
          <td><p>Number of smoothing iterations</p></td>
          <td>
              <em>required</em>
          </td>
        </tr>
        <tr>
          <td><code>use_cotan_weights</code></td>
          <td>
          </td>
          <td><p>Whether to use cotagent weighting (False by default)</p></td>
          <td>
              <em>required</em>
          </td>
        </tr>
    </tbody>
  </table>

  <p><strong>Returns:</strong></p>
  <table>
    <thead>
      <tr>
<th>Name</th>        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
        <tr>
<td><code>n</code></td>          <td>
          </td>
          <td><p>list of vertex normals of shape #v by 3</p></td>
        </tr>
    </tbody>
  </table>

  </div>

</div><hr />


<div class="doc doc-object doc-function">



<h2 id="point_cloud_utils.lloyd_2d" class="doc doc-heading">
<code class="highlight language-python"><span class="n">point_cloud_utils</span><span class="o">.</span><span class="n">lloyd_2d</span><span class="p">()</span></code>
  
  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-builtin"><code>builtin</code></small>
  </span>

</h2>


  <div class="doc doc-contents first">
  
      <p>lloyd_2d(n: int, num_lloyd: int = 10, num_newton: int = 10) -&gt; object</p>
<p>Generate n samples in the unit square, [0, 1]^2 using Lloyd's algorithm
(https://en.wikipedia.org/wiki/Lloyd%27s_algorithm).</p>

  <p><strong>Parameters:</strong></p>
  <table>
    <thead>
      <tr>
        <th>Name</th>
        <th>Type</th>
        <th>Description</th>
        <th>Default</th>
      </tr>
    </thead>
    <tbody>
        <tr>
          <td><code>n</code></td>
          <td>
          </td>
          <td><p>The number of 2d point samples to generate</p></td>
          <td>
              <em>required</em>
          </td>
        </tr>
        <tr>
          <td><code>num_lloyd</code></td>
          <td>
          </td>
          <td><p>The number of Lloyd iterations to do (default 10)</p></td>
          <td>
              <em>required</em>
          </td>
        </tr>
        <tr>
          <td><code>num_newton</code></td>
          <td>
          </td>
          <td><p>The number of Newton iterations to do when computing Voronoi diagrams (default 10)</p></td>
          <td>
              <em>required</em>
          </td>
        </tr>
    </tbody>
  </table>

  <p><strong>Returns:</strong></p>
  <table>
    <thead>
      <tr>
<th>Name</th>        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
        <tr>
<td><code>lloyd_points</code></td>          <td>
          </td>
          <td><p>a (n, 2)-shaped array of point samples in the unit square [0, 1]^2</p></td>
        </tr>
    </tbody>
  </table>

  </div>

</div><hr />


<div class="doc doc-object doc-function">



<h2 id="point_cloud_utils.lloyd_3d" class="doc doc-heading">
<code class="highlight language-python"><span class="n">point_cloud_utils</span><span class="o">.</span><span class="n">lloyd_3d</span><span class="p">()</span></code>
  
  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-builtin"><code>builtin</code></small>
  </span>

</h2>


  <div class="doc doc-contents first">
  
      <p>lloyd_3d(n: int, num_lloyd: int = 10, num_newton: int = 10) -&gt; object</p>
<p>Generate n samples in the unit cube, [0, 1]^3 using Lloyd's algorithm
(https://en.wikipedia.org/wiki/Lloyd%27s_algorithm).</p>

  <p><strong>Parameters:</strong></p>
  <table>
    <thead>
      <tr>
        <th>Name</th>
        <th>Type</th>
        <th>Description</th>
        <th>Default</th>
      </tr>
    </thead>
    <tbody>
        <tr>
          <td><code>n</code></td>
          <td>
          </td>
          <td><p>The number of 3d point samples to generate</p></td>
          <td>
              <em>required</em>
          </td>
        </tr>
        <tr>
          <td><code>num_lloyd</code></td>
          <td>
          </td>
          <td><p>The number of Lloyd iterations to do (default 10)</p></td>
          <td>
              <em>required</em>
          </td>
        </tr>
        <tr>
          <td><code>num_newton</code></td>
          <td>
          </td>
          <td><p>The number of Newton iterations to do when computing Voronoi diagrams (default 10)</p></td>
          <td>
              <em>required</em>
          </td>
        </tr>
    </tbody>
  </table>

  <p><strong>Returns:</strong></p>
  <table>
    <thead>
      <tr>
<th>Name</th>        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
        <tr>
<td><code>lloyd_pts</code></td>          <td>
          </td>
          <td><p>a (n, 3)-shaped array of point samples in the unit square [0, 1]^3</p></td>
        </tr>
    </tbody>
  </table>

  </div>

</div><hr />


<div class="doc doc-object doc-function">



<h2 id="point_cloud_utils.load_mesh_v" class="doc doc-heading">
<code class="highlight language-python"><span class="n">point_cloud_utils</span><span class="o">.</span><span class="n">load_mesh_v</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span></code>

</h2>


  <div class="doc doc-contents first">
  
      <p>Load a point cloud consisting only of vertex positions.
Point Cloud Utils currently supports PLY, OBJ, STL, OFF, VRML 2.0, X3D, COLLADA, 3DS.</p>

  <p><strong>Parameters:</strong></p>
  <table>
    <thead>
      <tr>
        <th>Name</th>
        <th>Type</th>
        <th>Description</th>
        <th>Default</th>
      </tr>
    </thead>
    <tbody>
        <tr>
          <td><code>filename</code></td>
          <td>
          </td>
          <td><p>Path to the file to be loaded. Must have a valid extension.</p></td>
          <td>
              <em>required</em>
          </td>
        </tr>
        <tr>
          <td><code>dtype</code></td>
          <td>
          </td>
          <td><p>The floating point type of loaded data (<code>np.float32</code> or <code>np.float64</code>)</p></td>
          <td>
                <code>float</code>
          </td>
        </tr>
    </tbody>
  </table>

  <p><strong>Returns:</strong></p>
  <table>
    <thead>
      <tr>
<th>Name</th>        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
        <tr>
<td><code>v</code></td>          <td>
          </td>
          <td><p>An (n, 3)-shaped numpy array of coordinates</p></td>
        </tr>
    </tbody>
  </table>

  </div>

</div><hr />


<div class="doc doc-object doc-function">



<h2 id="point_cloud_utils.load_mesh_vc" class="doc doc-heading">
<code class="highlight language-python"><span class="n">point_cloud_utils</span><span class="o">.</span><span class="n">load_mesh_vc</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span></code>

</h2>


  <div class="doc doc-contents first">
  
      <p>Load a point cloud consisting of vertex positions, and vertex colors.
Point Cloud Utils currently supports PLY, OBJ, STL, OFF, VRML 2.0, X3D, COLLADA, 3DS.</p>

  <p><strong>Parameters:</strong></p>
  <table>
    <thead>
      <tr>
        <th>Name</th>
        <th>Type</th>
        <th>Description</th>
        <th>Default</th>
      </tr>
    </thead>
    <tbody>
        <tr>
          <td><code>filename</code></td>
          <td>
          </td>
          <td><p>Path to the file to be loaded. Must have a valid extension.</p></td>
          <td>
              <em>required</em>
          </td>
        </tr>
        <tr>
          <td><code>dtype</code></td>
          <td>
          </td>
          <td><p>The floating point type of loaded data (<code>np.float32</code> or <code>np.float64</code>)</p></td>
          <td>
                <code>float</code>
          </td>
        </tr>
    </tbody>
  </table>

  <p><strong>Returns:</strong></p>
  <table>
    <thead>
      <tr>
<th>Name</th>        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
        <tr>
<td><code>v</code></td>          <td>
          </td>
          <td><p>An (n, 3)-shaped numpy array of coordinates</p></td>
        </tr>
        <tr>
<td><code>c</code></td>          <td>
          </td>
          <td><p>An (n, 3)-shaped or (n, 4)-shaped numpy array of per-vertex RGB or RGBA colors (from 0.0 to 1.0)</p></td>
        </tr>
    </tbody>
  </table>

  </div>

</div><hr />


<div class="doc doc-object doc-function">



<h2 id="point_cloud_utils.load_mesh_vf" class="doc doc-heading">
<code class="highlight language-python"><span class="n">point_cloud_utils</span><span class="o">.</span><span class="n">load_mesh_vf</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span></code>

</h2>


  <div class="doc doc-contents first">
  
      <p>Load a triangle mesh consisting of vertex positions and face indices.
Point Cloud Utils currently supports PLY, OBJ, STL, OFF, VRML 2.0, X3D, COLLADA, 3DS.</p>

  <p><strong>Parameters:</strong></p>
  <table>
    <thead>
      <tr>
        <th>Name</th>
        <th>Type</th>
        <th>Description</th>
        <th>Default</th>
      </tr>
    </thead>
    <tbody>
        <tr>
          <td><code>filename</code></td>
          <td>
          </td>
          <td><p>Path to the file to be loaded. Must have a valid extension.</p></td>
          <td>
              <em>required</em>
          </td>
        </tr>
        <tr>
          <td><code>dtype</code></td>
          <td>
          </td>
          <td><p>The floating point type of loaded data (<code>np.float32</code> or <code>np.float64</code>)</p></td>
          <td>
                <code>float</code>
          </td>
        </tr>
    </tbody>
  </table>

  <p><strong>Returns:</strong></p>
  <table>
    <thead>
      <tr>
<th>Name</th>        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
        <tr>
<td><code>v</code></td>          <td>
          </td>
          <td><p>An (n, 3)-shaped numpy array of coordinates</p></td>
        </tr>
        <tr>
<td><code>f</code></td>          <td>
          </td>
          <td><p>An (m, 3)-shaped integer numpy array of face indices into v</p></td>
        </tr>
    </tbody>
  </table>

  </div>

</div><hr />


<div class="doc doc-object doc-function">



<h2 id="point_cloud_utils.load_mesh_vfn" class="doc doc-heading">
<code class="highlight language-python"><span class="n">point_cloud_utils</span><span class="o">.</span><span class="n">load_mesh_vfn</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span></code>

</h2>


  <div class="doc doc-contents first">
  
      <p>Load a triangle mesh consisting of vertex positions, face indices, and vertex normals.
Point Cloud Utils currently supports PLY, OBJ, STL, OFF, VRML 2.0, X3D, COLLADA, 3DS.</p>

  <p><strong>Parameters:</strong></p>
  <table>
    <thead>
      <tr>
        <th>Name</th>
        <th>Type</th>
        <th>Description</th>
        <th>Default</th>
      </tr>
    </thead>
    <tbody>
        <tr>
          <td><code>filename</code></td>
          <td>
          </td>
          <td><p>Path to the file to be loaded. Must have a valid extension.</p></td>
          <td>
              <em>required</em>
          </td>
        </tr>
        <tr>
          <td><code>dtype</code></td>
          <td>
          </td>
          <td><p>The floating point type of loaded data (<code>np.float32</code> or <code>np.float64</code>)</p></td>
          <td>
                <code>float</code>
          </td>
        </tr>
    </tbody>
  </table>

  <p><strong>Returns:</strong></p>
  <table>
    <thead>
      <tr>
<th>Name</th>        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
        <tr>
<td><code>v</code></td>          <td>
          </td>
          <td><p>An (n, 3)-shaped numpy array of coordinates</p></td>
        </tr>
        <tr>
<td><code>f</code></td>          <td>
          </td>
          <td><p>An (m, 3)-shaped integer numpy array of face indices into v</p></td>
        </tr>
        <tr>
<td><code>n</code></td>          <td>
          </td>
          <td><p>An (n, 3)-shaped numpy array of per-vertex normals</p></td>
        </tr>
    </tbody>
  </table>

  </div>

</div><hr />


<div class="doc doc-object doc-function">



<h2 id="point_cloud_utils.load_mesh_vfnc" class="doc doc-heading">
<code class="highlight language-python"><span class="n">point_cloud_utils</span><span class="o">.</span><span class="n">load_mesh_vfnc</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span></code>

</h2>


  <div class="doc doc-contents first">
  
      <p>Load a triangle mesh consisting of vertex positions, face indices, vertex normals, and vertex colors.
Point Cloud Utils currently supports PLY, OBJ, STL, OFF, VRML 2.0, X3D, COLLADA, 3DS.</p>

  <p><strong>Parameters:</strong></p>
  <table>
    <thead>
      <tr>
        <th>Name</th>
        <th>Type</th>
        <th>Description</th>
        <th>Default</th>
      </tr>
    </thead>
    <tbody>
        <tr>
          <td><code>filename</code></td>
          <td>
          </td>
          <td><p>Path to the file to be loaded. Must have a valid extension.</p></td>
          <td>
              <em>required</em>
          </td>
        </tr>
        <tr>
          <td><code>dtype</code></td>
          <td>
          </td>
          <td><p>The floating point type of loaded data (<code>np.float32</code> or <code>np.float64</code>)</p></td>
          <td>
                <code>float</code>
          </td>
        </tr>
    </tbody>
  </table>

  <p><strong>Returns:</strong></p>
  <table>
    <thead>
      <tr>
<th>Name</th>        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
        <tr>
<td><code>v</code></td>          <td>
          </td>
          <td><p>An (n, 3)-shaped numpy array of coordinates</p></td>
        </tr>
        <tr>
<td><code>f</code></td>          <td>
          </td>
          <td><p>An (m, 3)-shaped integer numpy array of face indices into v</p></td>
        </tr>
        <tr>
<td><code>n</code></td>          <td>
          </td>
          <td><p>An (n, 3)-shaped numpy array of per-vertex normals</p></td>
        </tr>
        <tr>
<td><code>c</code></td>          <td>
          </td>
          <td><p>An (n, 3)-shaped or (n, 4)-shaped numpy array of per-vertex RGB or RGBA colors (from 0.0 to 1.0)</p></td>
        </tr>
    </tbody>
  </table>

  </div>

</div><hr />


<div class="doc doc-object doc-function">



<h2 id="point_cloud_utils.load_mesh_vn" class="doc doc-heading">
<code class="highlight language-python"><span class="n">point_cloud_utils</span><span class="o">.</span><span class="n">load_mesh_vn</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span></code>

</h2>


  <div class="doc doc-contents first">
  
      <p>Load a point cloud consisting of vertex positions, and vertex normals.
Point Cloud Utils currently supports PLY, OBJ, STL, OFF, VRML 2.0, X3D, COLLADA, 3DS.</p>

  <p><strong>Parameters:</strong></p>
  <table>
    <thead>
      <tr>
        <th>Name</th>
        <th>Type</th>
        <th>Description</th>
        <th>Default</th>
      </tr>
    </thead>
    <tbody>
        <tr>
          <td><code>filename</code></td>
          <td>
          </td>
          <td><p>Path to the file to be loaded. Must have a valid extension.</p></td>
          <td>
              <em>required</em>
          </td>
        </tr>
        <tr>
          <td><code>dtype</code></td>
          <td>
          </td>
          <td><p>The floating point type of loaded data (<code>np.float32</code> or <code>np.float64</code>)</p></td>
          <td>
                <code>float</code>
          </td>
        </tr>
    </tbody>
  </table>

  <p><strong>Returns:</strong></p>
  <table>
    <thead>
      <tr>
<th>Name</th>        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
        <tr>
<td><code>v</code></td>          <td>
          </td>
          <td><p>An (n, 3)-shaped numpy array of coordinates</p></td>
        </tr>
        <tr>
<td><code>n</code></td>          <td>
          </td>
          <td><p>An (n, 3)-shaped numpy array of per-vertex normals</p></td>
        </tr>
    </tbody>
  </table>

  </div>

</div><hr />


<div class="doc doc-object doc-function">



<h2 id="point_cloud_utils.load_mesh_vnc" class="doc doc-heading">
<code class="highlight language-python"><span class="n">point_cloud_utils</span><span class="o">.</span><span class="n">load_mesh_vnc</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span></code>

</h2>


  <div class="doc doc-contents first">
  
      <p>Load a point cloud consisting of vertex positions, vertex normals, and vertex colors.
Point Cloud Utils currently supports PLY, OBJ, STL, OFF, VRML 2.0, X3D, COLLADA, 3DS.</p>

  <p><strong>Parameters:</strong></p>
  <table>
    <thead>
      <tr>
        <th>Name</th>
        <th>Type</th>
        <th>Description</th>
        <th>Default</th>
      </tr>
    </thead>
    <tbody>
        <tr>
          <td><code>filename</code></td>
          <td>
          </td>
          <td><p>Path to the file to be loaded. Must have a valid extension.</p></td>
          <td>
              <em>required</em>
          </td>
        </tr>
        <tr>
          <td><code>dtype</code></td>
          <td>
          </td>
          <td><p>The floating point type of loaded data (<code>np.float32</code> or <code>np.float64</code>)</p></td>
          <td>
                <code>float</code>
          </td>
        </tr>
    </tbody>
  </table>

  <p><strong>Returns:</strong></p>
  <table>
    <thead>
      <tr>
<th>Name</th>        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
        <tr>
<td><code>v</code></td>          <td>
          </td>
          <td><p>An (n, 3)-shaped numpy array of coordinates</p></td>
        </tr>
        <tr>
<td><code>n</code></td>          <td>
          </td>
          <td><p>An (n, 3)-shaped numpy array of per-vertex normals</p></td>
        </tr>
        <tr>
<td><code>c</code></td>          <td>
          </td>
          <td><p>An (n, 3)-shaped or (n, 4)-shaped numpy array of per-vertex RGB or RGBA colors (from 0.0 to 1.0)</p></td>
        </tr>
    </tbody>
  </table>

  </div>

</div><hr />


<div class="doc doc-object doc-function">



<h2 id="point_cloud_utils.load_triangle_mesh" class="doc doc-heading">
<code class="highlight language-python"><span class="n">point_cloud_utils</span><span class="o">.</span><span class="n">load_triangle_mesh</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span></code>

</h2>


  <div class="doc doc-contents first">
  
      <p>Load a triangle mesh into a <code>TriangleMesh</code> class.
Point Cloud Utils currently supports PLY, OBJ, STL, OFF, VRML 2.0, X3D, COLLADA, 3DS.</p>

  <p><strong>Parameters:</strong></p>
  <table>
    <thead>
      <tr>
        <th>Name</th>
        <th>Type</th>
        <th>Description</th>
        <th>Default</th>
      </tr>
    </thead>
    <tbody>
        <tr>
          <td><code>filename</code></td>
          <td>
          </td>
          <td><p>Path to the file to be saved. Must have a valid extension.</p></td>
          <td>
              <em>required</em>
          </td>
        </tr>
        <tr>
          <td><code>dtype</code></td>
          <td>
          </td>
          <td><p>The type of floating point number to store the data in (np.float32 or np.float64)</p></td>
          <td>
                <code>np.float64</code>
          </td>
        </tr>
    </tbody>
  </table>

  <p><strong>Returns:</strong></p>
  <table>
    <thead>
      <tr>
<th>Name</th>        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
        <tr>
<td><code>mesh</code></td>          <td>
          </td>
          <td><p>A <code>TriangleMesh</code> class containing the loaded mesh</p></td>
        </tr>
    </tbody>
  </table>

  </div>

</div><hr />


<div class="doc doc-object doc-function">



<h2 id="point_cloud_utils.make_mesh_watertight" class="doc doc-heading">
<code class="highlight language-python"><span class="n">point_cloud_utils</span><span class="o">.</span><span class="n">make_mesh_watertight</span><span class="p">()</span></code>
  
  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-builtin"><code>builtin</code></small>
  </span>

</h2>


  <div class="doc doc-contents first">
  
      <p>make_mesh_watertight(v: numpy.ndarray, f: numpy.ndarray, resolution: float = 20000, seed: int = -1) -&gt; Tuple[object, object]</p>
<p>Convert a mesh into a watertight manifold</p>

  <p><strong>Parameters:</strong></p>
  <table>
    <thead>
      <tr>
        <th>Name</th>
        <th>Type</th>
        <th>Description</th>
        <th>Default</th>
      </tr>
    </thead>
    <tbody>
        <tr>
          <td><code>v</code></td>
          <td>
          </td>
          <td><p>(#v, 3)-shaped array of mesh vertex positions (one vertex position per row)</p></td>
          <td>
              <em>required</em>
          </td>
        </tr>
        <tr>
          <td><code>f</code></td>
          <td>
          </td>
          <td><p>(#f, 3)-shaped array of mesh face indexes into v (a row (fi, fj, fk) indicate the 3 vertices of a face)</p></td>
          <td>
              <em>required</em>
          </td>
        </tr>
        <tr>
          <td><code>resolution</code></td>
          <td>
          </td>
          <td><p>A resolution parameter for the algorithm</p></td>
          <td>
              <em>required</em>
          </td>
        </tr>
    </tbody>
  </table>

  <p><strong>Returns:</strong></p>
  <table>
    <thead>
      <tr>
<th>Name</th>        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
        <tr>
<td><code>vw</code></td>          <td>
          </td>
          <td><p>a (#vw, 3)-shaped array of vertices (one per row)</p></td>
        </tr>
        <tr>
<td><code>fw</code></td>          <td>
          </td>
          <td><p>a (#fw, 3)-shaped array of face indices into vw (one face per row)</p></td>
        </tr>
    </tbody>
  </table>

  </div>

</div><hr />


<div class="doc doc-object doc-function">



<h2 id="point_cloud_utils.marching_cubes_sparse_voxel_grid" class="doc doc-heading">
<code class="highlight language-python"><span class="n">point_cloud_utils</span><span class="o">.</span><span class="n">marching_cubes_sparse_voxel_grid</span><span class="p">()</span></code>
  
  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-builtin"><code>builtin</code></small>
  </span>

</h2>


  <div class="doc doc-contents first">
  
      <p>marching_cubes_sparse_voxel_grid(grid_scalars: numpy.ndarray, grid_coordinates: numpy.ndarray, cube_indices: numpy.ndarray, isovalue: float) -&gt; Tuple[object, object]</p>
<p>Run marching cubes on a hex mesh representing a sparse voxel grid (see also sparse_voxel_grid_to_hex_mesh)</p>

  <p><strong>Parameters:</strong></p>
  <table>
    <thead>
      <tr>
        <th>Name</th>
        <th>Type</th>
        <th>Description</th>
        <th>Default</th>
      </tr>
    </thead>
    <tbody>
        <tr>
          <td><code>grid_scalars</code></td>
          <td>
          </td>
          <td><p>An (n,) shaped array of scalar values at each hex mesh vertex</p></td>
          <td>
              <em>required</em>
          </td>
        </tr>
        <tr>
          <td><code>grid_coordinates</code></td>
          <td>
          </td>
          <td><p>An (n, 3) shaped array of hex mesh vertices</p></td>
          <td>
              <em>required</em>
          </td>
        </tr>
        <tr>
          <td><code>cube_indices</code></td>
          <td>
          </td>
          <td><p>An (m, 8) shaped array of indices into grid_coordinates where cube_indices[i, :] are the indices of the 8 points forming the i^th cube
          Note the cube indices must be ordered as:
          [[0, 0, 0],
          [1, 0, 0],
          [1, 1, 0],
          [0, 1, 0],
          [0, 0, 1],
          [1, 0, 1],
          [1, 1, 1],
          [0, 1, 1]]
          where [i, j, k] indicates the offset along the (x, y, z) axes from the bottom, back, left
          corner of the cube</p></td>
          <td>
              <em>required</em>
          </td>
        </tr>
        <tr>
          <td><code>isovalue</code></td>
          <td>
          </td>
          <td><p>Which level set to extract</p></td>
          <td>
              <em>required</em>
          </td>
        </tr>
    </tbody>
  </table>

  <p><strong>Returns:</strong></p>
  <table>
    <thead>
      <tr>
<th>Name</th>        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
        <tr>
<td><code>v</code></td>          <td>
          </td>
          <td><p>A (#v, 3) array of triangle mesh vertices</p></td>
        </tr>
        <tr>
<td><code>f</code></td>          <td>
          </td>
          <td><p>A (#f, 3) array of indices into v where f[i, :] are the indices into vof the 3 points forming the i^th triangle</p></td>
        </tr>
    </tbody>
  </table>

<details class="see-also">
  <summary>See Also</summary>
  <p>sparse_voxel_grid_to_hex_mesh</p>
</details>
  </div>

</div><hr />


<div class="doc doc-object doc-function">



<h2 id="point_cloud_utils.mesh_face_areas" class="doc doc-heading">
<code class="highlight language-python"><span class="n">point_cloud_utils</span><span class="o">.</span><span class="n">mesh_face_areas</span><span class="p">()</span></code>
  
  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-builtin"><code>builtin</code></small>
  </span>

</h2>


  <div class="doc doc-contents first">
  
      <p>mesh_face_areas(v: numpy.ndarray, f: numpy.ndarray, num_threads: int = -1) -&gt; object</p>
<p>Compute the areas of each face of a triangle mesh</p>

  <p><strong>Parameters:</strong></p>
  <table>
    <thead>
      <tr>
        <th>Name</th>
        <th>Type</th>
        <th>Description</th>
        <th>Default</th>
      </tr>
    </thead>
    <tbody>
        <tr>
          <td><code>v</code></td>
          <td>
          </td>
          <td><p>#v by 3 array of vertex positions (each row is a vertex)</p></td>
          <td>
              <em>required</em>
          </td>
        </tr>
        <tr>
          <td><code>f</code></td>
          <td>
          </td>
          <td><p>#f by 3 Matrix of face (triangle) indices</p></td>
          <td>
              <em>required</em>
          </td>
        </tr>
    </tbody>
  </table>

  <p><strong>Returns:</strong></p>
  <table>
    <thead>
      <tr>
<th>Name</th>        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
        <tr>
<td><code>areas</code></td>          <td>
          </td>
          <td><p>a numpy array of shape (#faces,) where areas[i] is the area of the face f[i]</p></td>
        </tr>
    </tbody>
  </table>

  </div>

</div><hr />


<div class="doc doc-object doc-function">



<h2 id="point_cloud_utils.mesh_mean_and_gaussian_curvatures" class="doc doc-heading">
<code class="highlight language-python"><span class="n">point_cloud_utils</span><span class="o">.</span><span class="n">mesh_mean_and_gaussian_curvatures</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="n">r</span><span class="o">=-</span><span class="mf">1.0</span><span class="p">)</span></code>

</h2>


  <div class="doc doc-contents first">
  
      <p>Estimate mean and Gaussian curvatures for a mesh</p>

  <p><strong>Parameters:</strong></p>
  <table>
    <thead>
      <tr>
        <th>Name</th>
        <th>Type</th>
        <th>Description</th>
        <th>Default</th>
      </tr>
    </thead>
    <tbody>
        <tr>
          <td><code>v</code></td>
          <td>
          </td>
          <td><p>#v by 3 Matrix of mesh vertex 3D positions</p></td>
          <td>
              <em>required</em>
          </td>
        </tr>
        <tr>
          <td><code>f</code></td>
          <td>
          </td>
          <td><p>#f by 3 Matrix of face (triangle) indices</p></td>
          <td>
              <em>required</em>
          </td>
        </tr>
        <tr>
          <td><code>r</code></td>
          <td>
          </td>
          <td><p>optional floating point radius of neighborhood to consider when estimating curvature
If set to a positive value, will use a more robust curvature estimation method (but may require some tuning)</p></td>
          <td>
                <code>-1.0</code>
          </td>
        </tr>
    </tbody>
  </table>

  <p><strong>Returns:</strong></p>
  <table>
    <thead>
      <tr>
<th>Name</th>        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
        <tr>
<td><code>kh</code></td>          <td>
          </td>
          <td><p>an array of shape (#v,) of per-vertex mean curvatures</p></td>
        </tr>
        <tr>
<td><code>kg</code></td>          <td>
          </td>
          <td><p>an array of shape (#v,) of per-vertex Gaussian curvatures</p></td>
        </tr>
    </tbody>
  </table>

  </div>

</div><hr />


<div class="doc doc-object doc-function">



<h2 id="point_cloud_utils.mesh_principal_curvatures" class="doc doc-heading">
<code class="highlight language-python"><span class="n">point_cloud_utils</span><span class="o">.</span><span class="n">mesh_principal_curvatures</span><span class="p">()</span></code>
  
  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-builtin"><code>builtin</code></small>
  </span>

</h2>


  <div class="doc doc-contents first">
  
      <p>mesh_principal_curvatures(v: numpy.ndarray, f: numpy.ndarray, r: float = -1.0) -&gt; Tuple[object, object, object, object]</p>
<p>Estimate principal curvature directions and magnitudes for a mesh</p>

  <p><strong>Parameters:</strong></p>
  <table>
    <thead>
      <tr>
        <th>Name</th>
        <th>Type</th>
        <th>Description</th>
        <th>Default</th>
      </tr>
    </thead>
    <tbody>
        <tr>
          <td><code>v</code></td>
          <td>
          </td>
          <td><p>#v by 3 Matrix of mesh vertex 3D positions</p></td>
          <td>
              <em>required</em>
          </td>
        </tr>
        <tr>
          <td><code>f</code></td>
          <td>
          </td>
          <td><p>#f by 3 Matrix of face (triangle) indices</p></td>
          <td>
              <em>required</em>
          </td>
        </tr>
        <tr>
          <td><code>r</code></td>
          <td>
          </td>
          <td><p>optional floating point radius of neighborhood to consider when estimating curvature</p></td>
          <td>
              <em>required</em>
          </td>
        </tr>
    </tbody>
  </table>

  <p><strong>Returns:</strong></p>
  <table>
    <thead>
      <tr>
<th>Name</th>        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
        <tr>
<td><code>k1</code></td>          <td>
          </td>
          <td><p>an array of shape (#v,) of maximum curvature magnitudes</p></td>
        </tr>
        <tr>
<td><code>k2</code></td>          <td>
          </td>
          <td><p>an array of shape (#v,) of minimum curvature magnitudes</p></td>
        </tr>
        <tr>
<td><code>d1</code></td>          <td>
          </td>
          <td><p>an array of shape (#v, 3) of maximum curvature directions</p></td>
        </tr>
        <tr>
<td><code>d2</code></td>          <td>
          </td>
          <td><p>an array of shape (#v, 3) of minimum curvature directions</p></td>
        </tr>
    </tbody>
  </table>

  </div>

</div><hr />


<div class="doc doc-object doc-function">



<h2 id="point_cloud_utils.morton_add" class="doc doc-heading">
<code class="highlight language-python"><span class="n">point_cloud_utils</span><span class="o">.</span><span class="n">morton_add</span><span class="p">()</span></code>
  
  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-builtin"><code>builtin</code></small>
  </span>

</h2>


  <div class="doc doc-contents first">
  
      <p>morton_add(codes_1: numpy.ndarray, codes_2: numpy.ndarray, num_threads: int = -1) -&gt; object</p>
<p>Add morton codes together (corresponding to adding the vectors they encode)</p>

  <p><strong>Parameters:</strong></p>
  <table>
    <thead>
      <tr>
        <th>Name</th>
        <th>Type</th>
        <th>Description</th>
        <th>Default</th>
      </tr>
    </thead>
    <tbody>
        <tr>
          <td><code>codes_1</code></td>
          <td>
          </td>
          <td><p>an (n,)-shaped array of morton codes</p></td>
          <td>
              <em>required</em>
          </td>
        </tr>
        <tr>
          <td><code>codes_2</code></td>
          <td>
          </td>
          <td><p>an (n,)-shaped array of morton codes</p></td>
          <td>
              <em>required</em>
          </td>
        </tr>
        <tr>
          <td><code>num_threads</code></td>
          <td>
          </td>
          <td><p>Number of threads to use. If set to -1, will use all available CPUs. If set to 0, will run in serial. Default is -1.</p></td>
          <td>
              <em>required</em>
          </td>
        </tr>
    </tbody>
  </table>

  <p><strong>Returns:</strong></p>
  <table>
    <thead>
      <tr>
<th>Name</th>        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
        <tr>
<td><code>morton_codes</code></td>          <td>
          </td>
          <td><p>an (n,)-shaped array of added morton codes</p></td>
        </tr>
    </tbody>
  </table>

  </div>

</div><hr />


<div class="doc doc-object doc-function">



<h2 id="point_cloud_utils.morton_decode" class="doc doc-heading">
<code class="highlight language-python"><span class="n">point_cloud_utils</span><span class="o">.</span><span class="n">morton_decode</span><span class="p">()</span></code>
  
  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-builtin"><code>builtin</code></small>
  </span>

</h2>


  <div class="doc doc-contents first">
  
      <p>morton_decode(codes: numpy.ndarray, num_threads: int = -1) -&gt; object</p>
<p>Decode n points along a Morton curve into 3D points</p>

  <p><strong>Parameters:</strong></p>
  <table>
    <thead>
      <tr>
        <th>Name</th>
        <th>Type</th>
        <th>Description</th>
        <th>Default</th>
      </tr>
    </thead>
    <tbody>
        <tr>
          <td><code>codes</code></td>
          <td>
          </td>
          <td><p>an (n,)-shaped array of Morton codes</p></td>
          <td>
              <em>required</em>
          </td>
        </tr>
    </tbody>
  </table>

  <p><strong>Returns:</strong></p>
  <table>
    <thead>
      <tr>
<th>Name</th>        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
        <tr>
<td><code>points</code></td>          <td>
          </td>
          <td><p>an (n, 3)-shaped array of 3D points</p></td>
        </tr>
    </tbody>
  </table>

  </div>

</div><hr />


<div class="doc doc-object doc-function">



<h2 id="point_cloud_utils.morton_encode" class="doc doc-heading">
<code class="highlight language-python"><span class="n">point_cloud_utils</span><span class="o">.</span><span class="n">morton_encode</span><span class="p">()</span></code>
  
  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-builtin"><code>builtin</code></small>
  </span>

</h2>


  <div class="doc doc-contents first">
  
      <p>morton_encode(pts: numpy.ndarray, num_threads: int = -1) -&gt; object</p>
<p>Encode n 3D points using Morton coding, possibly sorting them</p>

  <p><strong>Parameters:</strong></p>
  <table>
    <thead>
      <tr>
        <th>Name</th>
        <th>Type</th>
        <th>Description</th>
        <th>Default</th>
      </tr>
    </thead>
    <tbody>
        <tr>
          <td><code>pts</code></td>
          <td>
          </td>
          <td><p>an (n, 3)-shaped array of 3D points</p></td>
          <td>
              <em>required</em>
          </td>
        </tr>
        <tr>
          <td><code>num_threads</code></td>
          <td>
          </td>
          <td><p>Number of threads to use. If set to -1, will use all available CPUs. If set to 0, will run in serial. Default is -1.</p></td>
          <td>
              <em>required</em>
          </td>
        </tr>
    </tbody>
  </table>

  <p><strong>Returns:</strong></p>
  <table>
    <thead>
      <tr>
<th>Name</th>        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
        <tr>
<td><code>morton_codes</code></td>          <td>
          </td>
          <td><p>an (n,)-shaped array of morton encoded points</p></td>
        </tr>
    </tbody>
  </table>

  </div>

</div><hr />


<div class="doc doc-object doc-function">



<h2 id="point_cloud_utils.morton_knn" class="doc doc-heading">
<code class="highlight language-python"><span class="n">point_cloud_utils</span><span class="o">.</span><span class="n">morton_knn</span><span class="p">()</span></code>
  
  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-builtin"><code>builtin</code></small>
  </span>

</h2>


  <div class="doc doc-contents first">
  
      <p>morton_knn(codes: numpy.ndarray, qcodes: numpy.ndarray, k: int, sort_dist: bool = True) -&gt; object</p>
<p>Queries a sorted array of morton encoded points to find the (approximate) k nearest neighbors</p>

  <p><strong>Parameters:</strong></p>
  <table>
    <thead>
      <tr>
        <th>Name</th>
        <th>Type</th>
        <th>Description</th>
        <th>Default</th>
      </tr>
    </thead>
    <tbody>
        <tr>
          <td><code>codes</code></td>
          <td>
          </td>
          <td><p>an (n)-shaped array of morton codes</p></td>
          <td>
              <em>required</em>
          </td>
        </tr>
        <tr>
          <td><code>qcodes</code></td>
          <td>
          </td>
          <td><p>an (m)-shaped array of query codes</p></td>
          <td>
              <em>required</em>
          </td>
        </tr>
        <tr>
          <td><code>k</code></td>
          <td>
          </td>
          <td><p>an integer representing the number of nearest neighbors</p></td>
          <td>
              <em>required</em>
          </td>
        </tr>
        <tr>
          <td><code>sort_dist</code></td>
          <td>
          </td>
          <td><p>(optional, defaults to True) whether to return the nearest neigbors in distance sorted order</p></td>
          <td>
              <em>required</em>
          </td>
        </tr>
    </tbody>
  </table>

  <p><strong>Returns:</strong></p>
  <table>
    <thead>
      <tr>
<th>Name</th>        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
        <tr>
<td><code>nn_idx</code></td>          <td>
          </td>
          <td><p>an (m, k)-shaped array of indices into codes</p></td>
        </tr>
    </tbody>
  </table>

  </div>

</div><hr />


<div class="doc doc-object doc-function">



<h2 id="point_cloud_utils.morton_subtract" class="doc doc-heading">
<code class="highlight language-python"><span class="n">point_cloud_utils</span><span class="o">.</span><span class="n">morton_subtract</span><span class="p">()</span></code>
  
  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-builtin"><code>builtin</code></small>
  </span>

</h2>


  <div class="doc doc-contents first">
  
      <p>morton_subtract(codes_1: numpy.ndarray, codes_2: numpy.ndarray, num_threads: int = -1) -&gt; object</p>
<p>Subtract morton codes from each other (corresponding to adding the vectors they encode)</p>

  <p><strong>Parameters:</strong></p>
  <table>
    <thead>
      <tr>
        <th>Name</th>
        <th>Type</th>
        <th>Description</th>
        <th>Default</th>
      </tr>
    </thead>
    <tbody>
        <tr>
          <td><code>codes_1</code></td>
          <td>
          </td>
          <td><p>an (n,)-shaped array of morton codes</p></td>
          <td>
              <em>required</em>
          </td>
        </tr>
        <tr>
          <td><code>codes_2</code></td>
          <td>
          </td>
          <td><p>an (n,)-shaped array of morton codes</p></td>
          <td>
              <em>required</em>
          </td>
        </tr>
        <tr>
          <td><code>num_threads</code></td>
          <td>
          </td>
          <td><p>Number of threads to use. If set to -1, will use all available CPUs. If set to 0, will run in serial. Default is -1.</p></td>
          <td>
              <em>required</em>
          </td>
        </tr>
    </tbody>
  </table>

  <p><strong>Returns:</strong></p>
  <table>
    <thead>
      <tr>
<th>Name</th>        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
        <tr>
<td><code>morton_codes</code></td>          <td>
          </td>
          <td><p>an (n,)-shaped shaped array of added morton codes</p></td>
        </tr>
    </tbody>
  </table>

  </div>

</div><hr />


<div class="doc doc-object doc-function">



<h2 id="point_cloud_utils.one_sided_hausdorff_distance" class="doc doc-heading">
<code class="highlight language-python"><span class="n">point_cloud_utils</span><span class="o">.</span><span class="n">one_sided_hausdorff_distance</span><span class="p">()</span></code>
  
  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-builtin"><code>builtin</code></small>
  </span>

</h2>


  <div class="doc doc-contents first">
  
      <p>one_sided_hausdorff_distance(source: numpy.ndarray, target: numpy.ndarray, return_index: bool = True, squared_distances: bool = False, max_points_per_leaf: int = 10) -&gt; object</p>
<p>Compute the one sided Hausdorff distance from source to target</p>

  <p><strong>Parameters:</strong></p>
  <table>
    <thead>
      <tr>
        <th>Name</th>
        <th>Type</th>
        <th>Description</th>
        <th>Default</th>
      </tr>
    </thead>
    <tbody>
        <tr>
          <td><code>source</code></td>
          <td>
          </td>
          <td><p>n by 3 array of representing a set of n points (each row is a point of dimension 3)</p></td>
          <td>
              <em>required</em>
          </td>
        </tr>
        <tr>
          <td><code>target</code></td>
          <td>
          </td>
          <td><p>m by 3 array of representing a set of m points (each row is a point of dimension 3)</p></td>
          <td>
              <em>required</em>
          </td>
        </tr>
        <tr>
          <td><code>return_index</code></td>
          <td>
          </td>
          <td><p>Optionally return the index pair <code>(i, j)</code> into source and target such that <code>source[i, :]</code> and <code>target[j, :]</code> are the two points with maximum shortest distance.</p></td>
          <td>
              <em>required</em>
          </td>
        </tr>
        <tr>
          <td><code>squared_distances</code></td>
          <td>
          </td>
          <td><p>If set to True, then return squared L2 distances.</p></td>
          <td>
              <em>required</em>
          </td>
        </tr>
        <tr>
          <td><code>max_points_per_leaf</code></td>
          <td>
          </td>
          <td><p>the maximum number of points per leaf node in the KD tree used by this function. Default is 10.</p></td>
          <td>
              <em>required</em>
          </td>
        </tr>
    </tbody>
  </table>

  <p><strong>Returns:</strong></p>
  <table>
    <thead>
      <tr>
<th>Name</th>        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
        <tr>
<td><code>d</code></td>          <td>
          </td>
          <td><p>The largest shortest distance, <code>d</code> between each point in <code>source</code> and the points in <code>target</code>.</p></td>
        </tr>
        <tr>
<td><code>i</code></td>          <td>
          </td>
          <td><p>(n,)-shaped array of indices such that <code>source[i, :]</code> and <code>target[j, :]</code> are the two points with maximum shortest distance.</p></td>
        </tr>
        <tr>
<td><code>j</code></td>          <td>
          </td>
          <td><p>(m,)-shaped array of indices such that <code>source[i, :]</code> and <code>target[j, :]</code> are the two points with maximum shortest distance.</p></td>
        </tr>
    </tbody>
  </table>

  </div>

</div><hr />


<div class="doc doc-object doc-function">



<h2 id="point_cloud_utils.orient_mesh_faces" class="doc doc-heading">
<code class="highlight language-python"><span class="n">point_cloud_utils</span><span class="o">.</span><span class="n">orient_mesh_faces</span><span class="p">()</span></code>
  
  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-builtin"><code>builtin</code></small>
  </span>

</h2>


  <div class="doc doc-contents first">
  
      <p>orient_mesh_faces(f: numpy.ndarray, weighting_type: str = 'uniform') -&gt; Tuple[object, object]</p>
<p>Consistently orient faces of a mesh within each connected component</p>

  <p><strong>Parameters:</strong></p>
  <table>
    <thead>
      <tr>
        <th>Name</th>
        <th>Type</th>
        <th>Description</th>
        <th>Default</th>
      </tr>
    </thead>
    <tbody>
        <tr>
          <td><code>f</code></td>
          <td>
          </td>
          <td><p>(#f, 3)-shaped NumPy array of face (triangle) indices</p></td>
          <td>
              <em>required</em>
          </td>
        </tr>
    </tbody>
  </table>

  <p><strong>Returns:</strong></p>
  <table>
    <thead>
      <tr>
<th>Name</th>        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
        <tr>
<td><code>oriented_faces</code></td>          <td>
          </td>
          <td><p>(#f, 3)-shaped NumPy array of faces which are consistently oriented</p></td>
        </tr>
        <tr>
<td><code>face_components</code></td>          <td>
          </td>
          <td><p>(#f,)-shaped NumPy array of connected component ids (i.e. face_components[i] is the component id of facef[i])</p></td>
        </tr>
    </tbody>
  </table>

  </div>

</div><hr />


<div class="doc doc-object doc-function">



<h2 id="point_cloud_utils.pairwise_distances" class="doc doc-heading">
<code class="highlight language-python"><span class="n">point_cloud_utils</span><span class="o">.</span><span class="n">pairwise_distances</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">p</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span></code>

</h2>


  <div class="doc doc-contents first">
  
      <p>Compute the (batched) pairwise distance matrix between a and b which both have size [m, n, d] or [n, d]. The result is a tensor of size [m, n, n] (or [n, n]) whose entry [m, i, j] contains the distance_tensor between a[m, i, :] and b[m, j, :].</p>

  <p><strong>Parameters:</strong></p>
  <table>
    <thead>
      <tr>
        <th>Name</th>
        <th>Type</th>
        <th>Description</th>
        <th>Default</th>
      </tr>
    </thead>
    <tbody>
        <tr>
          <td><code>a</code></td>
          <td>
          </td>
          <td><p>A tensor containing m batches of n points of dimension d. i.e. of size (m, n, d)</p></td>
          <td>
              <em>required</em>
          </td>
        </tr>
        <tr>
          <td><code>b</code></td>
          <td>
          </td>
          <td><p>A tensor containing m batches of n points of dimension d. i.e. of size (m, n, d)</p></td>
          <td>
              <em>required</em>
          </td>
        </tr>
        <tr>
          <td><code>p</code></td>
          <td>
          </td>
          <td><p>Norm to use for the distance_tensor</p></td>
          <td>
                <code>None</code>
          </td>
        </tr>
    </tbody>
  </table>

  <p><strong>Returns:</strong></p>
  <table>
    <thead>
      <tr>
<th>Name</th>        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
        <tr>
<td><code>M</code></td>          <td>
          </td>
          <td><p>A (m, n, n)-shaped array containing the pairwise distance_tensor between each pair of inputs in a batch.</p></td>
        </tr>
    </tbody>
  </table>

  </div>

</div><hr />


<div class="doc doc-object doc-function">



<h2 id="point_cloud_utils.point_cloud_fast_winding_number" class="doc doc-heading">
<code class="highlight language-python"><span class="n">point_cloud_utils</span><span class="o">.</span><span class="n">point_cloud_fast_winding_number</span><span class="p">()</span></code>
  
  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-builtin"><code>builtin</code></small>
  </span>

</h2>


  <div class="doc doc-contents first">
  
      <p>point_cloud_fast_winding_number(p: numpy.ndarray, n: numpy.ndarray, a: numpy.ndarray, q: numpy.ndarray) -&gt; object</p>
<p>Compute a consistent inside/outside field given a point cloud and evaluate that field
at a set of query points</p>

  <p><strong>Parameters:</strong></p>
  <table>
    <thead>
      <tr>
        <th>Name</th>
        <th>Type</th>
        <th>Description</th>
        <th>Default</th>
      </tr>
    </thead>
    <tbody>
        <tr>
          <td><code>p</code></td>
          <td>
          </td>
          <td><p>(#p, 3)-shaped array of points</p></td>
          <td>
              <em>required</em>
          </td>
        </tr>
        <tr>
          <td><code>n</code></td>
          <td>
          </td>
          <td><p>(#p, 3)-shaped array of point normals at p</p></td>
          <td>
              <em>required</em>
          </td>
        </tr>
        <tr>
          <td><code>a</code></td>
          <td>
          </td>
          <td><p>(#p, 1)-shaped array of point areas (e.g. computed with pcu.estimate_point_cloud_areas)</p></td>
          <td>
              <em>required</em>
          </td>
        </tr>
        <tr>
          <td><code>q</code></td>
          <td>
          </td>
          <td><p>(#q, 3)-shaped array of query positions at which to evaluat the winding number field</p></td>
          <td>
              <em>required</em>
          </td>
        </tr>
    </tbody>
  </table>

  <p><strong>Returns:</strong></p>
  <table>
    <thead>
      <tr>
<th>Name</th>        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
        <tr>
<td><code>signs</code></td>          <td>
          </td>
          <td><p>(#q,)-shaped array with a sign value for each query point (positive for outside and negative for inside)</p></td>
        </tr>
    </tbody>
  </table>

  </div>

</div><hr />


<div class="doc doc-object doc-function">



<h2 id="point_cloud_utils.quantize_subdivided_sparse_voxel_grid" class="doc doc-heading">
<code class="highlight language-python"><span class="n">point_cloud_utils</span><span class="o">.</span><span class="n">quantize_subdivided_sparse_voxel_grid</span><span class="p">(</span><span class="n">fractional_grid_coordinates</span><span class="p">,</span> <span class="n">num_subdivs</span><span class="p">)</span></code>

</h2>


  <div class="doc doc-contents first">
  
      <p>subdivide_sparse_voxel_grid returns fractional voxel coordinates (since we are subdividing an integer grid).
This function transforms these fractional coordinates into integer coordinates. This operation can be undone
with unquantize_subdivided_sparse_voxel_grid</p>

  <p><strong>Parameters:</strong></p>
  <table>
    <thead>
      <tr>
        <th>Name</th>
        <th>Type</th>
        <th>Description</th>
        <th>Default</th>
      </tr>
    </thead>
    <tbody>
        <tr>
          <td><code>fractional_grid_coordinates</code></td>
          <td>
          </td>
          <td><p>An (n, 3) shaped array of fractional voxels coordinates returned by
                        subdivide_sparse_voxel_grid</p></td>
          <td>
              <em>required</em>
          </td>
        </tr>
        <tr>
          <td><code>num_subdivs</code></td>
          <td>
          </td>
          <td><p>The number of subdivision iterations used to compute fractional_grid_coordinates</p></td>
          <td>
              <em>required</em>
          </td>
        </tr>
    </tbody>
  </table>

  <p><strong>Returns:</strong></p>
  <table>
    <thead>
      <tr>
<th>Name</th>        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
        <tr>
<td><code>quantized_grid_coordinates</code></td>          <td>
          </td>
          <td><p>An (n, 3) shaped array of quantized grid coordinates</p></td>
        </tr>
    </tbody>
  </table>

<details class="see-also">
  <summary>See Also</summary>
  <p>subdivide_sparse_voxel_grid
unquantize_subdivided_sparse_voxel_grid</p>
</details>
  </div>

</div><hr />


<div class="doc doc-object doc-function">



<h2 id="point_cloud_utils.ray_mesh_intersection" class="doc doc-heading">
<code class="highlight language-python"><span class="n">point_cloud_utils</span><span class="o">.</span><span class="n">ray_mesh_intersection</span><span class="p">()</span></code>
  
  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-builtin"><code>builtin</code></small>
  </span>

</h2>


  <div class="doc doc-contents first">
  
      <p>ray_mesh_intersection(v: numpy.ndarray, f: numpy.ndarray, ray_o: numpy.ndarray, ray_d: numpy.ndarray, ray_near: float = 0.0, ray_far: float = inf) -&gt; Tuple[object, object, object]</p>
<p>Compute intersection between a set of rays and a triangle mesh</p>

  <p><strong>Parameters:</strong></p>
  <table>
    <thead>
      <tr>
        <th>Name</th>
        <th>Type</th>
        <th>Description</th>
        <th>Default</th>
      </tr>
    </thead>
    <tbody>
        <tr>
          <td><code>v</code></td>
          <td>
          </td>
          <td><p>#v by 3 array of vertex positions (each row is a vertex)</p></td>
          <td>
              <em>required</em>
          </td>
        </tr>
        <tr>
          <td><code>f</code></td>
          <td>
          </td>
          <td><p>#f by 3 Matrix of face (triangle) indices</p></td>
          <td>
              <em>required</em>
          </td>
        </tr>
        <tr>
          <td><code>ray_o</code></td>
          <td>
          </td>
          <td><p>array of shape (#rays, 3) of ray origins (one per row) or a single array of shape (3,) to use</p></td>
          <td>
              <em>required</em>
          </td>
        </tr>
        <tr>
          <td><code>ray_d</code></td>
          <td>
          </td>
          <td><p>array of shape (#rays, 3) of ray directions (one per row)</p></td>
          <td>
              <em>required</em>
          </td>
        </tr>
        <tr>
          <td><code>ray_near</code></td>
          <td>
          </td>
          <td><p>an optional floating point value indicating the distance along each ray to start searching (default 0.0)</p></td>
          <td>
              <em>required</em>
          </td>
        </tr>
        <tr>
          <td><code>ray_far</code></td>
          <td>
          </td>
          <td><p>an optional floating point value indicating the maximum distance along each ray to search (default inf)</p></td>
          <td>
              <em>required</em>
          </td>
        </tr>
    </tbody>
  </table>

  <p><strong>Returns:</strong></p>
  <table>
    <thead>
      <tr>
<th>Name</th>        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
        <tr>
<td><code>f_id</code></td>          <td>
          </td>
          <td><p>an array of shape (#rays,) representing the face id hit by each ray</p></td>
        </tr>
        <tr>
<td><code>bc</code></td>          <td>
          </td>
          <td><p>an array of shape (#rays, 3) where each row is the barycentric coordinates within each face of the ray intersection</p></td>
        </tr>
        <tr>
<td><code>t</code></td>          <td>
          </td>
          <td><p>the distance along each ray to the intersection</p></td>
        </tr>
    </tbody>
  </table>

  </div>

</div><hr />


<div class="doc doc-object doc-function">



<h2 id="point_cloud_utils.ray_surfel_intersection" class="doc doc-heading">
<code class="highlight language-python"><span class="n">point_cloud_utils</span><span class="o">.</span><span class="n">ray_surfel_intersection</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">ray_o</span><span class="p">,</span> <span class="n">ray_d</span><span class="p">,</span> <span class="n">r</span><span class="o">=</span><span class="mf">0.1</span><span class="p">,</span> <span class="n">subdivs</span><span class="o">=</span><span class="mi">4</span><span class="p">,</span> <span class="n">ray_near</span><span class="o">=</span><span class="mf">0.0</span><span class="p">,</span> <span class="n">ray_far</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">)</span></code>

</h2>


  <div class="doc doc-contents first">
  
      <p>Compute intersection between a set of rays and a point cloud converted to surfels (i.e. circular patches oriented
with the point normals)</p>

  <p><strong>Parameters:</strong></p>
  <table>
    <thead>
      <tr>
        <th>Name</th>
        <th>Type</th>
        <th>Description</th>
        <th>Default</th>
      </tr>
    </thead>
    <tbody>
        <tr>
          <td><code>p</code></td>
          <td>
          </td>
          <td><p>#p by 3 array of vertex positions (each row is a vertex)</p></td>
          <td>
              <em>required</em>
          </td>
        </tr>
        <tr>
          <td><code>n</code></td>
          <td>
          </td>
          <td><p>#p by 3 Matrix of vertex normals (each row is a vertex)</p></td>
          <td>
              <em>required</em>
          </td>
        </tr>
        <tr>
          <td><code>ray_o</code></td>
          <td>
          </td>
          <td><p>array of shape (#rays, 3) of ray origins (one per row) or a single array of shape (3,) to use</p></td>
          <td>
              <em>required</em>
          </td>
        </tr>
        <tr>
          <td><code>ray_d</code></td>
          <td>
          </td>
          <td><p>array of shape (#rays, 3) of ray directions (one per row)</p></td>
          <td>
              <em>required</em>
          </td>
        </tr>
        <tr>
          <td><code>r</code></td>
          <td>
          </td>
          <td><p>Array or Scalar describing the size of each geometry element (Either one radius per vertex, or a global size for the whole point cloud)</p></td>
          <td>
                <code>0.1</code>
          </td>
        </tr>
        <tr>
          <td><code>subdivs</code></td>
          <td>
          </td>
          <td><p>Number of times to subdivide the patch geometry for each point (i.e. # tris per cicle)</p></td>
          <td>
                <code>4</code>
          </td>
        </tr>
        <tr>
          <td><code>ray_near</code></td>
          <td>
          </td>
          <td><p>an optional floating point value indicating the distance along each ray to start searching (default 0.0)</p></td>
          <td>
                <code>0.0</code>
          </td>
        </tr>
        <tr>
          <td><code>ray_far</code></td>
          <td>
          </td>
          <td><p>an optional floating point value indicating the maximum distance along each ray to search (default inf)</p></td>
          <td>
                <code>np.inf</code>
          </td>
        </tr>
    </tbody>
  </table>

  <p><strong>Returns:</strong></p>
  <table>
    <thead>
      <tr>
<th>Name</th>        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
        <tr>
<td><code>t</code></td>          <td>
          </td>
          <td><p>a (#rays,) shaped array encoding the distance between the ray origin and intersection point for each ray (inf for missed rays)</p></td>
        </tr>
        <tr>
<td><code>pid</code></td>          <td>
          </td>
          <td><p>a (#rays,) shaped array of integer indices corresponding to which points were hit (-1 for a ray miss)</p></td>
        </tr>
    </tbody>
  </table>

  </div>

</div><hr />


<div class="doc doc-object doc-function">



<h2 id="point_cloud_utils.remove_unreferenced_mesh_vertices" class="doc doc-heading">
<code class="highlight language-python"><span class="n">point_cloud_utils</span><span class="o">.</span><span class="n">remove_unreferenced_mesh_vertices</span><span class="p">()</span></code>
  
  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-builtin"><code>builtin</code></small>
  </span>

</h2>


  <div class="doc doc-contents first">
  
      <p>remove_unreferenced_mesh_vertices(v: numpy.ndarray, f: numpy.ndarray) -&gt; Tuple[object, object, object, object]</p>
<p>Removes duplicated vertices from a triangle mesh two vertices are considered the same if their distance is below
some threshold</p>

  <p><strong>Parameters:</strong></p>
  <table>
    <thead>
      <tr>
        <th>Name</th>
        <th>Type</th>
        <th>Description</th>
        <th>Default</th>
      </tr>
    </thead>
    <tbody>
        <tr>
          <td><code>v</code></td>
          <td>
          </td>
          <td><p>(#v, 3)-shaped array of mesh vertex 3D positions</p></td>
          <td>
              <em>required</em>
          </td>
        </tr>
        <tr>
          <td><code>f</code></td>
          <td>
          </td>
          <td><p>(#f, 3)-shaped array of face (triangle) indices</p></td>
          <td>
              <em>required</em>
          </td>
        </tr>
    </tbody>
  </table>

  <p><strong>Returns:</strong></p>
  <table>
    <thead>
      <tr>
<th>Name</th>        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
        <tr>
<td><code>v_new</code></td>          <td>
          </td>
          <td><p>(#v_new, 3)-shaped array of mesh vertex positions without unreferenced vertices</p></td>
        </tr>
        <tr>
<td><code>f_new</code></td>          <td>
          </td>
          <td><p>(#f_new, 3)-shaped array of mesh faces indexing into v_new</p></td>
        </tr>
        <tr>
<td><code>correspondences_v</code></td>          <td>
          </td>
          <td><p>(#v, 1)-shaped array of indices so that v_new = correspondences_v[svi]</p></td>
        </tr>
        <tr>
<td><code>correspondences_f</code></td>          <td>
          </td>
          <td><p>(#f, 1)-shaped array of indices so that f_new = correspondences_f[svj]</p></td>
        </tr>
    </tbody>
  </table>

  </div>

</div><hr />


<div class="doc doc-object doc-function">



<h2 id="point_cloud_utils.sample_mesh_lloyd" class="doc doc-heading">
<code class="highlight language-python"><span class="n">point_cloud_utils</span><span class="o">.</span><span class="n">sample_mesh_lloyd</span><span class="p">()</span></code>
  
  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-builtin"><code>builtin</code></small>
  </span>

</h2>


  <div class="doc doc-contents first">
  
      <p>sample_mesh_lloyd(v: numpy.ndarray, f: numpy.ndarray, num_samples: int, num_lloyd: int = 10, num_newton: int = 10, return_mesh: bool = False) -&gt; object</p>
<p>Generate n samples on a surface defined by a triangle mesh using
Lloyd's algorithm (https://en.wikipedia.org/wiki/Lloyd%27s_algorithm).</p>

  <p><strong>Parameters:</strong></p>
  <table>
    <thead>
      <tr>
        <th>Name</th>
        <th>Type</th>
        <th>Description</th>
        <th>Default</th>
      </tr>
    </thead>
    <tbody>
        <tr>
          <td><code>v</code></td>
          <td>
          </td>
          <td><p>A #v by 3 array where each row is a vertex of the input mesh</p></td>
          <td>
              <em>required</em>
          </td>
        </tr>
        <tr>
          <td><code>f</code></td>
          <td>
          </td>
          <td><p>A #f by 3 array of indices into <code>v</code> where each row is a triangle of the input mesh.</p></td>
          <td>
              <em>required</em>
          </td>
        </tr>
        <tr>
          <td><code>n</code></td>
          <td>
          </td>
          <td><p>The number of surface samples to generate</p></td>
          <td>
              <em>required</em>
          </td>
        </tr>
        <tr>
          <td><code>num_lloyd</code></td>
          <td>
          </td>
          <td><p>The number of Lloyd iterations to do (default 10)</p></td>
          <td>
              <em>required</em>
          </td>
        </tr>
        <tr>
          <td><code>num_newton</code></td>
          <td>
          </td>
          <td><p>The number of Newton iterations to do when computing Voronoi diagrams (default 10)</p></td>
          <td>
              <em>required</em>
          </td>
        </tr>
    </tbody>
  </table>

  <p><strong>Returns:</strong></p>
  <table>
    <thead>
      <tr>
<th>Name</th>        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
        <tr>
<td><code>lloyd_pts</code></td>          <td>
          </td>
          <td><p>a (n, 3)-shaped array of point samples on the input surface defined by (v, f)</p></td>
        </tr>
    </tbody>
  </table>

  </div>

</div><hr />


<div class="doc doc-object doc-function">



<h2 id="point_cloud_utils.sample_mesh_poisson_disk" class="doc doc-heading">
<code class="highlight language-python"><span class="n">point_cloud_utils</span><span class="o">.</span><span class="n">sample_mesh_poisson_disk</span><span class="p">()</span></code>
  
  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-builtin"><code>builtin</code></small>
  </span>

</h2>


  <div class="doc doc-contents first">
  
      <p>sample_mesh_poisson_disk(v: numpy.ndarray, f: numpy.ndarray, num_samples: int, radius: float = 0.0, use_geodesic_distance: bool = True, best_choice_sampling: bool = True, random_seed: int = 0, sample_num_tolerance: float = 0.04, oversampling_factor: float = 40.0) -&gt; Tuple[object, object]</p>
<p>Downsample a point set (possibly on a mesh) so that samples are approximately evenly spaced. This function uses the method in ("Parallel Poisson Disk Sampling with Spectrum Analysis on Surface")[http://graphics.cs.umass.edu/pubs/sa_2010.pdf]</p>

  <p><strong>Parameters:</strong></p>
  <table>
    <thead>
      <tr>
        <th>Name</th>
        <th>Type</th>
        <th>Description</th>
        <th>Default</th>
      </tr>
    </thead>
    <tbody>
        <tr>
          <td><code>v</code></td>
          <td>
          </td>
          <td><p>#v by 3 array of mesh vertex positions</p></td>
          <td>
              <em>required</em>
          </td>
        </tr>
        <tr>
          <td><code>f</code></td>
          <td>
          </td>
          <td><p>#f by 3 array of mesh face indices</p></td>
          <td>
              <em>required</em>
          </td>
        </tr>
        <tr>
          <td><code>num_samples</code></td>
          <td>
          </td>
          <td><p>desired number of Poisson Disk samples. Note that the actual number of returned samples will not be exactly this value (see sample_num_tolerance) to control the range of possible returned samples. Note: If this value &lt;= 0, then the parameter radius is used to decide the number of samples</p></td>
          <td>
              <em>required</em>
          </td>
        </tr>
        <tr>
          <td><code>radius</code></td>
          <td>
          </td>
          <td><p>desired separation between points, if num_samples &lt;= 0, then this value is used to determine the sampling (-1.0, by default).</p></td>
          <td>
              <em>required</em>
          </td>
        </tr>
        <tr>
          <td><code>use_geodesic_distance</code></td>
          <td>
          </td>
          <td><p>Use geodesic distance on the mesh downsampling. (True by default).</p></td>
          <td>
              <em>required</em>
          </td>
        </tr>
        <tr>
          <td><code>best_choice_sampling</code></td>
          <td>
          </td>
          <td><p>When downsampling, always keep the sample that will remove the fewest number of samples. (True by default).</p></td>
          <td>
              <em>required</em>
          </td>
        </tr>
        <tr>
          <td><code>random_seed</code></td>
          <td>
          </td>
          <td><p>A random seed used to generate the samples. Passing in 0 will use the current time. (0 by default).</p></td>
          <td>
              <em>required</em>
          </td>
        </tr>
        <tr>
          <td><code>sample_num_tolerance</code></td>
          <td>
          </td>
          <td><p>If you requested a target number of samples, by passsing num_samples &gt; 0, then this function will return between (1 - sample_num_tolerance) * num_samples and (1 + sample_num_tolerance) * num_samples. Setting a very small value for this parameter will increase convergence time. (0.04 by default).</p></td>
          <td>
              <em>required</em>
          </td>
        </tr>
        <tr>
          <td><code>oversampling_factor</code></td>
          <td>
          </td>
          <td><p>To generate Poisson disk samples, we first generate a very dense (uniform) random sampling of the mesh, then prune these down to have the Poisson disk property. This parameter controls how many dense samples are generated. i.e. we generate oversampling_factor * num_samples samples (if you passed in radius, we estimate num_samples from the input points and radius). This parameter must be &gt;= 1.0. (Default 40.0).</p></td>
          <td>
              <em>required</em>
          </td>
        </tr>
    </tbody>
  </table>

  <p><strong>Returns:</strong></p>
  <table>
    <thead>
      <tr>
<th>Name</th>        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
        <tr>
<td><code>f_idx</code></td>          <td>
          </td>
          <td><p>a (m,)-shaped array of face indices into f where m is the number of Poisson-disk samples</p></td>
        </tr>
        <tr>
<td><code>bc</code></td>          <td>
          </td>
          <td><p>a (m, 3)-shaped array of barycentric coordinates where m is the number of Poisson-disk samples</p></td>
        </tr>
    </tbody>
  </table>

  </div>

</div><hr />


<div class="doc doc-object doc-function">



<h2 id="point_cloud_utils.sample_mesh_random" class="doc doc-heading">
<code class="highlight language-python"><span class="n">point_cloud_utils</span><span class="o">.</span><span class="n">sample_mesh_random</span><span class="p">()</span></code>
  
  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-builtin"><code>builtin</code></small>
  </span>

</h2>


  <div class="doc doc-contents first">
  
      <p>sample_mesh_random(v: numpy.ndarray, f: numpy.ndarray, num_samples: int, random_seed: int = 0) -&gt; Tuple[object, object]</p>
<p>Generate uniformly distributed random point samples on a mesh</p>

  <p><strong>Parameters:</strong></p>
  <table>
    <thead>
      <tr>
        <th>Name</th>
        <th>Type</th>
        <th>Description</th>
        <th>Default</th>
      </tr>
    </thead>
    <tbody>
        <tr>
          <td><code>v</code></td>
          <td>
          </td>
          <td><p>(#v, 3)-shaped array of mesh vertex positions</p></td>
          <td>
              <em>required</em>
          </td>
        </tr>
        <tr>
          <td><code>f</code></td>
          <td>
          </td>
          <td><p>(#f, 3)-shaped array of mesh face indices</p></td>
          <td>
              <em>required</em>
          </td>
        </tr>
        <tr>
          <td><code>num_samples</code></td>
          <td>
          </td>
          <td><p>The number of samples to generate</p></td>
          <td>
              <em>required</em>
          </td>
        </tr>
        <tr>
          <td><code>random_seed</code></td>
          <td>
          </td>
          <td><p>A random seed used to generate the samples. Passing in 0 will use the current time. (0 by default).</p></td>
          <td>
              <em>required</em>
          </td>
        </tr>
    </tbody>
  </table>

  <p><strong>Returns:</strong></p>
  <table>
    <thead>
      <tr>
<th>Name</th>        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
        <tr>
<td><code>f_idx</code></td>          <td>
          </td>
          <td><p>(num_samples,) shaped array of face indices into f where</p></td>
        </tr>
        <tr>
<td><code>bc</code></td>          <td>
          </td>
          <td><p>(num_samples, 3) shaped array of barycentric coordinates</p></td>
        </tr>
    </tbody>
  </table>

  </div>

</div><hr />


<div class="doc doc-object doc-function">



<h2 id="point_cloud_utils.save_mesh_v" class="doc doc-heading">
<code class="highlight language-python"><span class="n">point_cloud_utils</span><span class="o">.</span><span class="n">save_mesh_v</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span></code>

</h2>


  <div class="doc doc-contents first">
  
      <p>Save a point cloud consisting only of vertex positions.
Point Cloud Utils currently supports PLY, OBJ, STL, OFF, VRML 2.0, X3D, COLLADA, 3DS.</p>

  <p><strong>Parameters:</strong></p>
  <table>
    <thead>
      <tr>
        <th>Name</th>
        <th>Type</th>
        <th>Description</th>
        <th>Default</th>
      </tr>
    </thead>
    <tbody>
        <tr>
          <td><code>filename</code></td>
          <td>
          </td>
          <td><p>Path to the file to be saved. Must have a valid extension.</p></td>
          <td>
              <em>required</em>
          </td>
        </tr>
        <tr>
          <td><code>v</code></td>
          <td>
          </td>
          <td><p>An (n, 3)-shaped numpy array of coordinates</p></td>
          <td>
              <em>required</em>
          </td>
        </tr>
        <tr>
          <td><code>dtype</code></td>
          <td>
          </td>
          <td><p>The floating point written to the file (<code>np.float32</code> or <code>np.float64</code>)</p></td>
          <td>
                <code>np.float32</code>
          </td>
        </tr>
    </tbody>
  </table>

  </div>

</div><hr />


<div class="doc doc-object doc-function">



<h2 id="point_cloud_utils.save_mesh_vc" class="doc doc-heading">
<code class="highlight language-python"><span class="n">point_cloud_utils</span><span class="o">.</span><span class="n">save_mesh_vc</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span></code>

</h2>


  <div class="doc doc-contents first">
  
      <p>Save a point cloud consisting of vertex positions and vertex colors.
Point Cloud Utils currently supports PLY, OBJ, STL, OFF, VRML 2.0, X3D, COLLADA, 3DS.</p>

  <p><strong>Parameters:</strong></p>
  <table>
    <thead>
      <tr>
        <th>Name</th>
        <th>Type</th>
        <th>Description</th>
        <th>Default</th>
      </tr>
    </thead>
    <tbody>
        <tr>
          <td><code>filename</code></td>
          <td>
          </td>
          <td><p>Path to the file to be saved. Must have a valid extension.</p></td>
          <td>
              <em>required</em>
          </td>
        </tr>
        <tr>
          <td><code>v</code></td>
          <td>
          </td>
          <td><p>An (n, 3)-shaped numpy array of coordinates</p></td>
          <td>
              <em>required</em>
          </td>
        </tr>
        <tr>
          <td><code>c</code></td>
          <td>
          </td>
          <td><p>An (n, 3)-shaped or (n, 4)-shaped numpy array of per-vertex RGB or RGBA colors (from 0.0 to 1.0)</p></td>
          <td>
              <em>required</em>
          </td>
        </tr>
        <tr>
          <td><code>dtype</code></td>
          <td>
          </td>
          <td><p>The floating point written to the file (<code>np.float32</code> or <code>np.float64</code>)</p></td>
          <td>
                <code>np.float32</code>
          </td>
        </tr>
    </tbody>
  </table>

  </div>

</div><hr />


<div class="doc doc-object doc-function">



<h2 id="point_cloud_utils.save_mesh_vf" class="doc doc-heading">
<code class="highlight language-python"><span class="n">point_cloud_utils</span><span class="o">.</span><span class="n">save_mesh_vf</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span></code>

</h2>


  <div class="doc doc-contents first">
  
      <p>Save a triangle mesh consisting of vertex positions and face indices.
Point Cloud Utils currently supports PLY, OBJ, STL, OFF, VRML 2.0, X3D, COLLADA, 3DS.</p>

  <p><strong>Parameters:</strong></p>
  <table>
    <thead>
      <tr>
        <th>Name</th>
        <th>Type</th>
        <th>Description</th>
        <th>Default</th>
      </tr>
    </thead>
    <tbody>
        <tr>
          <td><code>filename</code></td>
          <td>
          </td>
          <td><p>Path to the file to be saved. Must have a valid extension.</p></td>
          <td>
              <em>required</em>
          </td>
        </tr>
        <tr>
          <td><code>v</code></td>
          <td>
          </td>
          <td><p>An (n, 3)-shaped numpy array of coordinates</p></td>
          <td>
              <em>required</em>
          </td>
        </tr>
        <tr>
          <td><code>f</code></td>
          <td>
          </td>
          <td><p>An (m, 3)-shaped integer numpy array of face indices into v</p></td>
          <td>
              <em>required</em>
          </td>
        </tr>
        <tr>
          <td><code>dtype</code></td>
          <td>
          </td>
          <td><p>The floating point written to the file (<code>np.float32</code> or <code>np.float64</code>)</p></td>
          <td>
                <code>np.float32</code>
          </td>
        </tr>
    </tbody>
  </table>

  </div>

</div><hr />


<div class="doc doc-object doc-function">



<h2 id="point_cloud_utils.save_mesh_vfn" class="doc doc-heading">
<code class="highlight language-python"><span class="n">point_cloud_utils</span><span class="o">.</span><span class="n">save_mesh_vfn</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span></code>

</h2>


  <div class="doc doc-contents first">
  
      <p>Save a triangle mesh consisting of vertex positions, face indices, and vertex normals.
Point Cloud Utils currently supports PLY, OBJ, STL, OFF, VRML 2.0, X3D, COLLADA, 3DS.</p>

  <p><strong>Parameters:</strong></p>
  <table>
    <thead>
      <tr>
        <th>Name</th>
        <th>Type</th>
        <th>Description</th>
        <th>Default</th>
      </tr>
    </thead>
    <tbody>
        <tr>
          <td><code>filename</code></td>
          <td>
          </td>
          <td><p>Path to the file to be saved. Must have a valid extension.</p></td>
          <td>
              <em>required</em>
          </td>
        </tr>
        <tr>
          <td><code>v</code></td>
          <td>
          </td>
          <td><p>An (n, 3)-shaped numpy array of coordinates</p></td>
          <td>
              <em>required</em>
          </td>
        </tr>
        <tr>
          <td><code>f</code></td>
          <td>
          </td>
          <td><p>An (m, 3)-shaped integer numpy array of face indices into v</p></td>
          <td>
              <em>required</em>
          </td>
        </tr>
        <tr>
          <td><code>n</code></td>
          <td>
          </td>
          <td><p>An (n, 3)-shaped numpy array of per-vertex normals</p></td>
          <td>
              <em>required</em>
          </td>
        </tr>
        <tr>
          <td><code>dtype</code></td>
          <td>
          </td>
          <td><p>The floating point written to the file (<code>np.float32</code> or <code>np.float64</code>)</p></td>
          <td>
                <code>np.float32</code>
          </td>
        </tr>
    </tbody>
  </table>

  </div>

</div><hr />


<div class="doc doc-object doc-function">



<h2 id="point_cloud_utils.save_mesh_vfnc" class="doc doc-heading">
<code class="highlight language-python"><span class="n">point_cloud_utils</span><span class="o">.</span><span class="n">save_mesh_vfnc</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span></code>

</h2>


  <div class="doc doc-contents first">
  
      <p>Save a triangle mesh consisting of vertex positions, face indices, vertex normals, and vertex colors.
Point Cloud Utils currently supports PLY, OBJ, STL, OFF, VRML 2.0, X3D, COLLADA, 3DS.</p>

  <p><strong>Parameters:</strong></p>
  <table>
    <thead>
      <tr>
        <th>Name</th>
        <th>Type</th>
        <th>Description</th>
        <th>Default</th>
      </tr>
    </thead>
    <tbody>
        <tr>
          <td><code>filename</code></td>
          <td>
          </td>
          <td><p>Path to the file to be saved. Must have a valid extension.</p></td>
          <td>
              <em>required</em>
          </td>
        </tr>
        <tr>
          <td><code>v</code></td>
          <td>
          </td>
          <td><p>An (n, 3)-shaped numpy array of coordinates</p></td>
          <td>
              <em>required</em>
          </td>
        </tr>
        <tr>
          <td><code>f</code></td>
          <td>
          </td>
          <td><p>An (m, 3)-shaped integer numpy array of face indices into v</p></td>
          <td>
              <em>required</em>
          </td>
        </tr>
        <tr>
          <td><code>n</code></td>
          <td>
          </td>
          <td><p>An (n, 3)-shaped numpy array of per-vertex normals</p></td>
          <td>
              <em>required</em>
          </td>
        </tr>
        <tr>
          <td><code>c</code></td>
          <td>
          </td>
          <td><p>An (n, 3)-shaped or (n, 4)-shaped numpy array of per-vertex RGB or RGBA colors (from 0.0 to 1.0)</p></td>
          <td>
              <em>required</em>
          </td>
        </tr>
        <tr>
          <td><code>dtype</code></td>
          <td>
          </td>
          <td><p>The floating point written to the file (<code>np.float32</code> or <code>np.float64</code>)</p></td>
          <td>
                <code>np.float32</code>
          </td>
        </tr>
    </tbody>
  </table>

  </div>

</div><hr />


<div class="doc doc-object doc-function">



<h2 id="point_cloud_utils.save_mesh_vn" class="doc doc-heading">
<code class="highlight language-python"><span class="n">point_cloud_utils</span><span class="o">.</span><span class="n">save_mesh_vn</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span></code>

</h2>


  <div class="doc doc-contents first">
  
      <p>Save a point cloud consisting of vertex positions and vertex normals.
Point Cloud Utils currently supports PLY, OBJ, STL, OFF, VRML 2.0, X3D, COLLADA, 3DS.</p>

  <p><strong>Parameters:</strong></p>
  <table>
    <thead>
      <tr>
        <th>Name</th>
        <th>Type</th>
        <th>Description</th>
        <th>Default</th>
      </tr>
    </thead>
    <tbody>
        <tr>
          <td><code>filename</code></td>
          <td>
          </td>
          <td><p>Path to the file to be saved. Must have a valid extension.</p></td>
          <td>
              <em>required</em>
          </td>
        </tr>
        <tr>
          <td><code>v</code></td>
          <td>
          </td>
          <td><p>An (n, 3)-shaped numpy array of coordinates</p></td>
          <td>
              <em>required</em>
          </td>
        </tr>
        <tr>
          <td><code>n</code></td>
          <td>
          </td>
          <td><p>An (n, 3)-shaped numpy array of per-vertex normals</p></td>
          <td>
              <em>required</em>
          </td>
        </tr>
        <tr>
          <td><code>dtype</code></td>
          <td>
          </td>
          <td><p>The floating point written to the file (<code>np.float32</code> or <code>np.float64</code>)</p></td>
          <td>
                <code>np.float32</code>
          </td>
        </tr>
    </tbody>
  </table>

  </div>

</div><hr />


<div class="doc doc-object doc-function">



<h2 id="point_cloud_utils.save_mesh_vnc" class="doc doc-heading">
<code class="highlight language-python"><span class="n">point_cloud_utils</span><span class="o">.</span><span class="n">save_mesh_vnc</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span></code>

</h2>


  <div class="doc doc-contents first">
  
      <p>Save a point cloud consisting of vertex positions, vertex normals, and vertex colors.
Point Cloud Utils currently supports PLY, OBJ, STL, OFF, VRML 2.0, X3D, COLLADA, 3DS.</p>

  <p><strong>Parameters:</strong></p>
  <table>
    <thead>
      <tr>
        <th>Name</th>
        <th>Type</th>
        <th>Description</th>
        <th>Default</th>
      </tr>
    </thead>
    <tbody>
        <tr>
          <td><code>filename</code></td>
          <td>
          </td>
          <td><p>Path to the file to be saved. Must have a valid extension.</p></td>
          <td>
              <em>required</em>
          </td>
        </tr>
        <tr>
          <td><code>v</code></td>
          <td>
          </td>
          <td><p>An (n, 3)-shaped numpy array of coordinates</p></td>
          <td>
              <em>required</em>
          </td>
        </tr>
        <tr>
          <td><code>n</code></td>
          <td>
          </td>
          <td><p>An (n, 3)-shaped numpy array of per-vertex normals</p></td>
          <td>
              <em>required</em>
          </td>
        </tr>
        <tr>
          <td><code>c</code></td>
          <td>
          </td>
          <td><p>An (n, 3)-shaped or (n, 4)-shaped numpy array of per-vertex RGB or RGBA colors (from 0.0 to 1.0)</p></td>
          <td>
              <em>required</em>
          </td>
        </tr>
        <tr>
          <td><code>dtype</code></td>
          <td>
          </td>
          <td><p>The floating point written to the file (<code>np.float32</code> or <code>np.float64</code>)</p></td>
          <td>
                <code>np.float32</code>
          </td>
        </tr>
    </tbody>
  </table>

  </div>

</div><hr />


<div class="doc doc-object doc-function">



<h2 id="point_cloud_utils.save_triangle_mesh" class="doc doc-heading">
<code class="highlight language-python"><span class="n">point_cloud_utils</span><span class="o">.</span><span class="n">save_triangle_mesh</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">f</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">vn</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">vt</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">vc</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">vq</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">vr</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">vti</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">vflags</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">fn</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">fc</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">fq</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">fflags</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">wc</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">wn</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">wt</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">wti</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">textures</span><span class="o">=</span><span class="p">[],</span> <span class="n">normal_maps</span><span class="o">=</span><span class="p">[],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span></code>

</h2>


  <div class="doc doc-contents first">
  
      <p>Save a triangle mesh to a file with various per-vertex, per-face, and per-wedge attributes. Each argument (except v)
is optional and can be None.</p>

  <p><strong>Parameters:</strong></p>
  <table>
    <thead>
      <tr>
        <th>Name</th>
        <th>Type</th>
        <th>Description</th>
        <th>Default</th>
      </tr>
    </thead>
    <tbody>
        <tr>
          <td><code>filename</code></td>
          <td>
                <code>   </code>
          </td>
          <td><p>Path to the mesh to save. The type of file will be determined from the file extension.</p></td>
          <td>
              <em>required</em>
          </td>
        </tr>
        <tr>
          <td><code>v</code></td>
          <td>
                <code>          </code>
          </td>
          <td><p>[V, 3]-shaped numpy array of per-vertex positions</p></td>
          <td>
              <em>required</em>
          </td>
        </tr>
        <tr>
          <td><code>f</code></td>
          <td>
                <code>          </code>
          </td>
          <td><p>[F, 3]-shaped numpy array of integer face indices into TrianglMesh.vertex_data.positions (or None)</p></td>
          <td>
                <code>None</code>
          </td>
        </tr>
        <tr>
          <td><code>vn</code></td>
          <td>
                <code>         </code>
          </td>
          <td><p>[V, 3]-shaped numpy array of per-vertex normals (or None)</p></td>
          <td>
                <code>None</code>
          </td>
        </tr>
        <tr>
          <td><code>vt</code></td>
          <td>
                <code>         </code>
          </td>
          <td><p>[V, 2]-shaped numpy array of per-vertex uv coordinates (or None)</p></td>
          <td>
                <code>None</code>
          </td>
        </tr>
        <tr>
          <td><code>vc</code></td>
          <td>
                <code>         </code>
          </td>
          <td><p>[V, 4]-shaped numpy array of per-vertex RBGA colors in [0.0, 1.0] (or None)</p></td>
          <td>
                <code>None</code>
          </td>
        </tr>
        <tr>
          <td><code>vq</code></td>
          <td>
                <code>         </code>
          </td>
          <td><p>[V,]-shaped numpy array of per-vertex quality measures (or None)</p></td>
          <td>
                <code>None</code>
          </td>
        </tr>
        <tr>
          <td><code>vr</code></td>
          <td>
                <code>         </code>
          </td>
          <td><p>[V,]-shaped numpy array of per-vertex curvature radii (or None)</p></td>
          <td>
                <code>None</code>
          </td>
        </tr>
        <tr>
          <td><code>vti</code></td>
          <td>
                <code>        </code>
          </td>
          <td><p>[V,]-shaped numpy array of integer indices into TriangleMesh.textures indicating which texture to use at this vertex (or None)</p></td>
          <td>
                <code>None</code>
          </td>
        </tr>
        <tr>
          <td><code>vflags</code></td>
          <td>
                <code>     </code>
          </td>
          <td><p>[V,]-shaped numpy array of 32-bit integer flags per vertex (or None)</p></td>
          <td>
                <code>None</code>
          </td>
        </tr>
        <tr>
          <td><code>fn</code></td>
          <td>
                <code>         </code>
          </td>
          <td><p>[F, 3]-shaped numpy array of per-face normals (or None)</p></td>
          <td>
                <code>None</code>
          </td>
        </tr>
        <tr>
          <td><code>fc</code></td>
          <td>
                <code>         </code>
          </td>
          <td><p>[F, 4]-shaped numpy array of per-face RBGA colors in [0.0, 1.0] (or None)</p></td>
          <td>
                <code>None</code>
          </td>
        </tr>
        <tr>
          <td><code>fq</code></td>
          <td>
                <code>         </code>
          </td>
          <td><p>[F,]-shaped numpy array of per-face quality measures (or None)</p></td>
          <td>
                <code>None</code>
          </td>
        </tr>
        <tr>
          <td><code>fflags</code></td>
          <td>
                <code>     </code>
          </td>
          <td><p>[F,]-shaped numpy array of 32-bit integer flags per face (or None)</p></td>
          <td>
                <code>None</code>
          </td>
        </tr>
        <tr>
          <td><code>wc</code></td>
          <td>
                <code>         </code>
          </td>
          <td><p>[F, 3, 4]-shaped numpy array of per-wedge RBGA colors in [0.0, 1.0] (or None)</p></td>
          <td>
                <code>None</code>
          </td>
        </tr>
        <tr>
          <td><code>wn</code></td>
          <td>
                <code>         </code>
          </td>
          <td><p>[F, 3, 3]-shaped numpy array of per-wedge normals (or None)</p></td>
          <td>
                <code>None</code>
          </td>
        </tr>
        <tr>
          <td><code>wt</code></td>
          <td>
                <code>         </code>
          </td>
          <td><p>[F, 3, 2]-shaped numpy array of per-wedge] uv coordinates (or None)</p></td>
          <td>
                <code>None</code>
          </td>
        </tr>
        <tr>
          <td><code>wti</code></td>
          <td>
                <code>        </code>
          </td>
          <td><p>[F, 3]-shaped numpy array of integer indices into TriangleMesh.textures indicating which</p></td>
          <td>
                <code>None</code>
          </td>
        </tr>
        <tr>
          <td><code>textures</code></td>
          <td>
                <code>   </code>
          </td>
          <td><p>A list of paths to texture image files for this mesh</p></td>
          <td>
                <code>[]</code>
          </td>
        </tr>
        <tr>
          <td><code>normal_maps</code></td>
          <td>
          </td>
          <td><p>A list of paths to texture image files for this mesh</p></td>
          <td>
                <code>[]</code>
          </td>
        </tr>
        <tr>
          <td><code>dtype</code></td>
          <td>
                <code>      </code>
          </td>
          <td><p>The floating point written to the file (<code>np.float32</code> or <code>np.float64</code>)</p></td>
          <td>
                <code>np.float32</code>
          </td>
        </tr>
    </tbody>
  </table>

  </div>

</div><hr />


<div class="doc doc-object doc-function">



<h2 id="point_cloud_utils.signed_distance_to_mesh" class="doc doc-heading">
<code class="highlight language-python"><span class="n">point_cloud_utils</span><span class="o">.</span><span class="n">signed_distance_to_mesh</span><span class="p">()</span></code>
  
  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-builtin"><code>builtin</code></small>
  </span>

</h2>


  <div class="doc doc-contents first">
  
      <p>signed_distance_to_mesh(p: numpy.ndarray, v: numpy.ndarray, f: numpy.ndarray, lower_bound: float = -inf, upper_bound: float = inf) -&gt; Tuple[object, object, object]</p>
<p>Computes signed distances of a point cloud with respect to a Mesh using Fast Winding Numbers</p>

  <p><strong>Parameters:</strong></p>
  <table>
    <thead>
      <tr>
        <th>Name</th>
        <th>Type</th>
        <th>Description</th>
        <th>Default</th>
      </tr>
    </thead>
    <tbody>
        <tr>
          <td><code>p</code></td>
          <td>
          </td>
          <td><p>(#p, 3)-shaped array point cloud (one 3D point per row)</p></td>
          <td>
              <em>required</em>
          </td>
        </tr>
        <tr>
          <td><code>v</code></td>
          <td>
          </td>
          <td><p>(#v, 3)-shaped array of mesh vertex positions (one vertex position per row)</p></td>
          <td>
              <em>required</em>
          </td>
        </tr>
        <tr>
          <td><code>f</code></td>
          <td>
          </td>
          <td><p>(#f, 3)-shaped array of mesh face indexes into v (a row (fi, fj, fk) indicate the 3 vertices of a face)</p></td>
          <td>
              <em>required</em>
          </td>
        </tr>
        <tr>
          <td><code>lower_bound</code></td>
          <td>
          </td>
          <td><p>The minimum distance value possible (use this to clamp SDF values). negative infinite by default</p></td>
          <td>
              <em>required</em>
          </td>
        </tr>
        <tr>
          <td><code>upper_bound</code></td>
          <td>
          </td>
          <td><p>The maximum distance value possible (use this to clamp SDF values). negative infinite by default</p></td>
          <td>
              <em>required</em>
          </td>
        </tr>
    </tbody>
  </table>

  <p><strong>Returns:</strong></p>
  <table>
    <thead>
      <tr>
<th>Name</th>        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
        <tr>
<td><code>s</code></td>          <td>
          </td>
          <td><p>a (#p,) shaped array of signed distance values for each query point in p</p></td>
        </tr>
        <tr>
<td><code>fi</code></td>          <td>
          </td>
          <td><p>a (#p,) shaped array of indices to the closest face for each query point in p</p></td>
        </tr>
        <tr>
<td><code>bc</code></td>          <td>
          </td>
          <td><p>a (#p, 3) shaped array of barycentric coordinates for the closest point on the mesh to each query point in p</p></td>
        </tr>
    </tbody>
  </table>

  </div>

</div><hr />


<div class="doc doc-object doc-function">



<h2 id="point_cloud_utils.sinkhorn" class="doc doc-heading">
<code class="highlight language-python"><span class="n">point_cloud_utils</span><span class="o">.</span><span class="n">sinkhorn</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">M</span><span class="p">,</span> <span class="n">eps</span><span class="p">,</span> <span class="n">max_iters</span><span class="o">=</span><span class="mi">100</span><span class="p">,</span> <span class="n">stop_thresh</span><span class="o">=</span><span class="mf">0.001</span><span class="p">)</span></code>

</h2>


  <div class="doc doc-contents first">
  
      <p>Compute the (batched) Sinkhorn correspondences between two dirac delta distributions, U, and V.
This implementation is numerically stable with float32.</p>

  <p><strong>Parameters:</strong></p>
  <table>
    <thead>
      <tr>
        <th>Name</th>
        <th>Type</th>
        <th>Description</th>
        <th>Default</th>
      </tr>
    </thead>
    <tbody>
        <tr>
          <td><code>a</code></td>
          <td>
          </td>
          <td><p>A m-sized minibatch of weights for each dirac in the first distribution, U. i.e. shape = (m, n)</p></td>
          <td>
              <em>required</em>
          </td>
        </tr>
        <tr>
          <td><code>b</code></td>
          <td>
          </td>
          <td><p>A m-sized minibatch of weights for each dirac in the second distribution, V. i.e. shape = (m, n)</p></td>
          <td>
              <em>required</em>
          </td>
        </tr>
        <tr>
          <td><code>M</code></td>
          <td>
          </td>
          <td><p>A minibatch of n-by-n tensors storing the distance between each pair of diracs in U and V. i.e. shape = (m, n, n) and each i.e. M[k, i, j] = ||u[k,_i] - v[k, j]||</p></td>
          <td>
              <em>required</em>
          </td>
        </tr>
        <tr>
          <td><code>eps</code></td>
          <td>
          </td>
          <td><p>The reciprocal of the sinkhorn regularization parameter</p></td>
          <td>
              <em>required</em>
          </td>
        </tr>
        <tr>
          <td><code>max_iters</code></td>
          <td>
          </td>
          <td><p>The maximum number of Sinkhorn iterations</p></td>
          <td>
                <code>100</code>
          </td>
        </tr>
        <tr>
          <td><code>stop_thresh</code></td>
          <td>
          </td>
          <td><p>Stop if the change in iterates is below this value</p></td>
          <td>
                <code>0.001</code>
          </td>
        </tr>
    </tbody>
  </table>

  <p><strong>Returns:</strong></p>
  <table>
    <thead>
      <tr>
<th>Name</th>        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
        <tr>
<td><code>P</code></td>          <td>
          </td>
          <td><p>An (m, n, n)-shaped array of correspondences between distributions U and V</p></td>
        </tr>
    </tbody>
  </table>

  </div>

</div><hr />


<div class="doc doc-object doc-function">



<h2 id="point_cloud_utils.sparse_voxel_grid_boundary" class="doc doc-heading">
<code class="highlight language-python"><span class="n">point_cloud_utils</span><span class="o">.</span><span class="n">sparse_voxel_grid_boundary</span><span class="p">()</span></code>
  
  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-builtin"><code>builtin</code></small>
  </span>

</h2>


  <div class="doc doc-contents first">
  
      <p>sparse_voxel_grid_boundary(grid_coordinates: numpy.ndarray) -&gt; object</p>

  </div>

</div><hr />


<div class="doc doc-object doc-function">



<h2 id="point_cloud_utils.sparse_voxel_grid_from_pointcloud" class="doc doc-heading">
<code class="highlight language-python"><span class="n">point_cloud_utils</span><span class="o">.</span><span class="n">sparse_voxel_grid_from_pointcloud</span><span class="p">(</span><span class="n">points</span><span class="p">,</span> <span class="n">voxel_size</span><span class="p">,</span> <span class="n">origin</span><span class="o">=</span><span class="p">(</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">))</span></code>

</h2>


  <div class="doc doc-contents first">
  
      <p>Construct a sparse voxel grid containing a point cloud, optionally returning the voxel index for each point.</p>

  <p><strong>Parameters:</strong></p>
  <table>
    <thead>
      <tr>
        <th>Name</th>
        <th>Type</th>
        <th>Description</th>
        <th>Default</th>
      </tr>
    </thead>
    <tbody>
        <tr>
          <td><code>points</code></td>
          <td>
          </td>
          <td><p>An (n, 3) shaped array of points (one per row)</p></td>
          <td>
              <em>required</em>
          </td>
        </tr>
        <tr>
          <td><code>voxel_size</code></td>
          <td>
          </td>
          <td><p>Either a scalar representing the sidelength of a voxel or a triple representing the sidelength of a
        voxel along each axis.</p></td>
          <td>
              <em>required</em>
          </td>
        </tr>
        <tr>
          <td><code>origin</code></td>
          <td>
          </td>
          <td><p>The origin of the point cloud corresponding to the bottom, back, left corner of the (0, 0, 0) voxel.</p></td>
          <td>
                <code>(0.0, 0.0, 0.0)</code>
          </td>
        </tr>
    </tbody>
  </table>

  <p><strong>Returns:</strong></p>
  <table>
    <thead>
      <tr>
<th>Name</th>        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
        <tr>
<td><code>grid_coordinates</code></td>          <td>
          </td>
          <td><p>An (n, 3)-shaped array of integer grid coordinates corresponding to voxels in the sparse grid</p></td>
        </tr>
        <tr>
<td><code>point_to_vox_idx</code></td>          <td>
          </td>
          <td><p>An (#points,)-shaped array where the i^th entry point_to_vox_idx[i] is the index into
            grid_coordinates of of the voxel containing points[i]</p></td>
        </tr>
    </tbody>
  </table>

  </div>

</div><hr />


<div class="doc doc-object doc-function">



<h2 id="point_cloud_utils.sparse_voxel_grid_to_hex_mesh" class="doc doc-heading">
<code class="highlight language-python"><span class="n">point_cloud_utils</span><span class="o">.</span><span class="n">sparse_voxel_grid_to_hex_mesh</span><span class="p">(</span><span class="n">grid_coordinates</span><span class="p">,</span> <span class="n">voxel_size</span><span class="o">=</span><span class="mf">1.0</span><span class="p">,</span> <span class="n">origin</span><span class="o">=</span><span class="p">(</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span></code>

</h2>


  <div class="doc doc-contents first">
  
      <p>Convert a sparse voxel grid where the voxel indices represent the centers of each voxel coordinate into a
hexahedral mesh.</p>
<p>i.e. a pair of arrays (v, c) where v has shape (n, 3) and each row is a vertex position
     and c has shape (m, 8) where the i^th row c[i, :] are the indices into v of the 8 corners of the i^th cube</p>

  <p><strong>Parameters:</strong></p>
  <table>
    <thead>
      <tr>
        <th>Name</th>
        <th>Type</th>
        <th>Description</th>
        <th>Default</th>
      </tr>
    </thead>
    <tbody>
        <tr>
          <td><code>grid_coordinates</code></td>
          <td>
          </td>
          <td><p>An (n, 3) shaped integer array of voxels coordinates in the sparse voxel grid</p></td>
          <td>
              <em>required</em>
          </td>
        </tr>
        <tr>
          <td><code>voxel_size</code></td>
          <td>
          </td>
          <td><p>Either a scalar encoding the length of one voxel along an axis or a triple encoding the length of a
        voxel on each of 3 axes</p></td>
          <td>
                <code>1.0</code>
          </td>
        </tr>
        <tr>
          <td><code>origin</code></td>
          <td>
          </td>
          <td><p>A triple encoding a global offset for the hex mesh (i.e. all vertices will have origin added to them).
    Default is (0.0, 0.0, 0.0).</p></td>
          <td>
                <code>(0.0, 0.0, 0.0)</code>
          </td>
        </tr>
        <tr>
          <td><code>dtype</code></td>
          <td>
          </td>
          <td><p>The scalar type of vertices to return.
Default is np.float64.</p></td>
          <td>
                <code>np.float64</code>
          </td>
        </tr>
    </tbody>
  </table>

  <p><strong>Returns:</strong></p>
  <table>
    <thead>
      <tr>
<th>Name</th>        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
        <tr>
<td><code>vertices</code></td>          <td>
          </td>
          <td><p>An (n, 3) shaped array where each row vertices[i, :] is a vertex position in the hex mesh</p></td>
        </tr>
        <tr>
<td><code>cubes</code></td>          <td>
          </td>
          <td><p>An (m, 8) shaped array of indices into v where each row cubes[j, :] are indices of the 8 points forming
the j^th cube</p></td>
        </tr>
    </tbody>
  </table>

  </div>

</div><hr />


<div class="doc doc-object doc-function">



<h2 id="point_cloud_utils.subdivide_sparse_voxel_grid" class="doc doc-heading">
<code class="highlight language-python"><span class="n">point_cloud_utils</span><span class="o">.</span><span class="n">subdivide_sparse_voxel_grid</span><span class="p">(</span><span class="n">grid_coordinates</span><span class="p">,</span> <span class="n">num_subdivs</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span></code>

</h2>


  <div class="doc doc-contents first">
  
      <p>Subdivide a sparse voxel grid such that every subdivision round splits each voxel into 8 subvoxels.</p>

  <p><strong>Parameters:</strong></p>
  <table>
    <thead>
      <tr>
        <th>Name</th>
        <th>Type</th>
        <th>Description</th>
        <th>Default</th>
      </tr>
    </thead>
    <tbody>
        <tr>
          <td><code>grid_coordinates</code></td>
          <td>
          </td>
          <td><p>An (n, 3) shaped integer array of voxels coordinates in the sparse voxel grid</p></td>
          <td>
              <em>required</em>
          </td>
        </tr>
        <tr>
          <td><code>num_subdivs</code></td>
          <td>
          </td>
          <td><p>The number of subdivision iterations to perform</p></td>
          <td>
                <code>1</code>
          </td>
        </tr>
    </tbody>
  </table>

<details class="new_grid_coordinates">
  <summary>An (m, 3) shaped array containing (fractional) coordinates representing the subdivided grid</summary>
  <p>voxel grid. To convert to integer coordinates you can run:
integer_grid_coords = quantize_subdivided_sparse_voxel_grid(num_subdivs)</p>
</details>
  </div>

</div><hr />


<div class="doc doc-object doc-function">



<h2 id="point_cloud_utils.surfel_geometry" class="doc doc-heading">
<code class="highlight language-python"><span class="n">point_cloud_utils</span><span class="o">.</span><span class="n">surfel_geometry</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">r</span><span class="o">=</span><span class="mf">0.1</span><span class="p">,</span> <span class="n">subdivs</span><span class="o">=</span><span class="mi">7</span><span class="p">)</span></code>

</h2>


  <div class="doc doc-contents first">
  
      <p>Generate geometry for a point cloud encoded as surfels (i.e. circular patches centered at each point and oriented
perpendicularly to each normal)</p>

  <p><strong>Parameters:</strong></p>
  <table>
    <thead>
      <tr>
        <th>Name</th>
        <th>Type</th>
        <th>Description</th>
        <th>Default</th>
      </tr>
    </thead>
    <tbody>
        <tr>
          <td><code>p</code></td>
          <td>
          </td>
          <td><p>#p by 3 array of vertex positions (each row is a vertex)</p></td>
          <td>
              <em>required</em>
          </td>
        </tr>
        <tr>
          <td><code>n</code></td>
          <td>
          </td>
          <td><p>#p by 3 array of vertex normals (each row is a vertex)</p></td>
          <td>
              <em>required</em>
          </td>
        </tr>
        <tr>
          <td><code>r</code></td>
          <td>
          </td>
          <td><p>Array or Scalar describing the size of each geometry element (Either one radius per vertex, or a global size for the whole point cloud)</p></td>
          <td>
                <code>0.1</code>
          </td>
        </tr>
        <tr>
          <td><code>subdivs</code></td>
          <td>
          </td>
          <td><p>Number of times to subdivide the patch geometry for each point (i.e. # tris per cicle)</p></td>
          <td>
                <code>7</code>
          </td>
        </tr>
    </tbody>
  </table>

  <p><strong>Returns:</strong></p>
  <table>
    <thead>
      <tr>
<th>Name</th>        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
        <tr>
<td><code>verts</code></td>          <td>
          </td>
          <td><p>an array of shape (#output_vertices, 3)</p></td>
        </tr>
        <tr>
<td><code>faces</code></td>          <td>
          </td>
          <td><p>an array of shape (#output_faces, 3) indexing into verts</p></td>
        </tr>
    </tbody>
  </table>

  </div>

</div><hr />


<div class="doc doc-object doc-function">



<h2 id="point_cloud_utils.triangle_soup_fast_winding_number" class="doc doc-heading">
<code class="highlight language-python"><span class="n">point_cloud_utils</span><span class="o">.</span><span class="n">triangle_soup_fast_winding_number</span><span class="p">()</span></code>
  
  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-builtin"><code>builtin</code></small>
  </span>

</h2>


  <div class="doc doc-contents first">
  
      <p>triangle_soup_fast_winding_number(v: numpy.ndarray, f: numpy.ndarray, p: numpy.ndarray) -&gt; object</p>
<p>Compute a consistent inside/outside field given a triangle soup and evaluate that field
at a set of query points</p>

  <p><strong>Parameters:</strong></p>
  <table>
    <thead>
      <tr>
        <th>Name</th>
        <th>Type</th>
        <th>Description</th>
        <th>Default</th>
      </tr>
    </thead>
    <tbody>
        <tr>
          <td><code>v</code></td>
          <td>
          </td>
          <td><p>(#v, 3)-shaped array of mesh vertex positions (one vertex position per row)</p></td>
          <td>
              <em>required</em>
          </td>
        </tr>
        <tr>
          <td><code>f</code></td>
          <td>
          </td>
          <td><p>(#f, 3)-shaped array of mesh face indexes into v (a row (fi, fj, fk) indicate the 3 vertices of a face)</p></td>
          <td>
              <em>required</em>
          </td>
        </tr>
        <tr>
          <td><code>q</code></td>
          <td>
          </td>
          <td><p>(#q, 3)-shaped array of query positions at which to evaluat the winding number field</p></td>
          <td>
              <em>required</em>
          </td>
        </tr>
    </tbody>
  </table>

  <p><strong>Returns:</strong></p>
  <table>
    <thead>
      <tr>
        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
        <tr>
          <td>
          </td>
          <td><p>A (#q,)-shaped array with a sign value for each query point (positive for outside and</p></td>
        </tr>
        <tr>
          <td>
          </td>
          <td><p>negative for inside)</p></td>
        </tr>
    </tbody>
  </table>

  </div>

</div><hr />


<div class="doc doc-object doc-function">



<h2 id="point_cloud_utils.unquantize_subdivided_sparse_voxel_grid" class="doc doc-heading">
<code class="highlight language-python"><span class="n">point_cloud_utils</span><span class="o">.</span><span class="n">unquantize_subdivided_sparse_voxel_grid</span><span class="p">(</span><span class="n">quantized_grid_coordinates</span><span class="p">,</span> <span class="n">num_subdivs</span><span class="p">)</span></code>

</h2>


  <div class="doc doc-contents first">
  
      <p>Undo quantization done by quantize_subdivided_sparse_voxel_grid.</p>

  <p><strong>Parameters:</strong></p>
  <table>
    <thead>
      <tr>
        <th>Name</th>
        <th>Type</th>
        <th>Description</th>
        <th>Default</th>
      </tr>
    </thead>
    <tbody>
        <tr>
          <td><code>quantized_grid_coordinates</code></td>
          <td>
          </td>
          <td><p>An (n, 3) shaped array of quantized voxels coordinates returned by
                        quantize_subdivided_sparse_voxel_grid</p></td>
          <td>
              <em>required</em>
          </td>
        </tr>
        <tr>
          <td><code>num_subdivs</code></td>
          <td>
          </td>
          <td><p>The number of subdivision iterations used to compute the original fractional coordinates</p></td>
          <td>
              <em>required</em>
          </td>
        </tr>
    </tbody>
  </table>

  <p><strong>Returns:</strong></p>
  <table>
    <thead>
      <tr>
<th>Name</th>        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
        <tr>
<td><code>fractional_grid_coordinates</code></td>          <td>
          </td>
          <td><p>An (n, 3) shaped array of fractional grid coordinates</p></td>
        </tr>
    </tbody>
  </table>

<details class="see-also">
  <summary>See Also</summary>
  <p>subdivide_sparse_voxel_grid
quantize_subdivided_sparse_voxel_grid</p>
</details>
  </div>

</div><hr />


<div class="doc doc-object doc-function">



<h2 id="point_cloud_utils.voronoi_centroids_unit_cube" class="doc doc-heading">
<code class="highlight language-python"><span class="n">point_cloud_utils</span><span class="o">.</span><span class="n">voronoi_centroids_unit_cube</span><span class="p">()</span></code>
  
  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-builtin"><code>builtin</code></small>
  </span>

</h2>


  <div class="doc doc-contents first">
  
      <p>voronoi_centroids_unit_cube(centers: numpy.ndarray) -&gt; object</p>
<p>Generate n samples in the unit cube, [0, 1]^3 using Lloyd's algorithm
(https://en.wikipedia.org/wiki/Lloyd%27s_algorithm).</p>

  <p><strong>Parameters:</strong></p>
  <table>
    <thead>
      <tr>
        <th>Name</th>
        <th>Type</th>
        <th>Description</th>
        <th>Default</th>
      </tr>
    </thead>
    <tbody>
        <tr>
          <td><code>n</code></td>
          <td>
          </td>
          <td><p>The number of 3d point samples to generate</p></td>
          <td>
              <em>required</em>
          </td>
        </tr>
        <tr>
          <td><code>num_lloyd</code></td>
          <td>
          </td>
          <td><p>The number of Lloyd iterations to do (default 10)</p></td>
          <td>
              <em>required</em>
          </td>
        </tr>
        <tr>
          <td><code>num_newton</code></td>
          <td>
          </td>
          <td><p>The number of Newton iterations to do when computing Voronoi diagrams (default 10)</p></td>
          <td>
              <em>required</em>
          </td>
        </tr>
    </tbody>
  </table>

  <p><strong>Returns:</strong></p>
  <table>
    <thead>
      <tr>
<th>Name</th>        <th>Type</th>
        <th>Description</th>
      </tr>
    </thead>
    <tbody>
        <tr>
<td><code>lloyd_pts</code></td>          <td>
          </td>
          <td><p>a (n, 3)-shaped array of point samples in the unit square [0, 1]^3</p></td>
        </tr>
    </tbody>
  </table>

  </div>

</div><hr />
              
            </div>
          </div><footer>
    <div class="rst-footer-buttons" role="navigation" aria-label="Footer Navigation">
        <a href="../cleaning_shapenet/" class="btn btn-neutral float-left" title="Making a ShapeNet SDF dataset"><span class="icon icon-circle-arrow-left"></span> Previous</a>
    </div>

  <hr/>

  <div role="contentinfo">
    <!-- Copyright etc -->
  </div>

  Built with <a href="https://www.mkdocs.org/">MkDocs</a> using a <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>.
</footer>
          
        </div>
      </div>

    </section>

  </div>

  <div class="rst-versions" role="note" aria-label="Versions">
  <span class="rst-current-version" data-toggle="rst-current-version">
    
        <span>
          <a href="https://github.com/fwilliams/point-cloud-utils" class="fa fa-github" style="color: #fcfcfc"> GitHub</a>
        </span>
    
    
      <span><a href="../cleaning_shapenet/" style="color: #fcfcfc">&laquo; Previous</a></span>
    
    
  </span>
</div>
    <script>var base_url = '../..';</script>
    <script src="../../js/theme_extra.js" defer></script>
    <script src="../../js/theme.js" defer></script>
      <script src="../../javascripts/mathjax.js" defer></script>
      <script src="https://polyfill.io/v3/polyfill.min.js?features=es6" defer></script>
      <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js" defer></script>
      <script src="../../search/main.js" defer></script>
    <script defer>
        window.onload = function () {
            SphinxRtdTheme.Navigation.enable(true);
        };
    </script>

</body>
</html>
